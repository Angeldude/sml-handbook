        Objective Caml version 3.09.3

# - : unit = ()
type dummy_interactive = START_INTERACTIVE | END_INTERACTIVE
- : unit = ()
- : unit = ()
val open_box : int -> unit = <fun>
val close_box : unit -> unit = <fun>
val print_string : string -> unit = <fun>
val print_as : int -> string -> unit = <fun>
val print_int : int -> unit = <fun>
val print_float : float -> unit = <fun>
val print_char : char -> unit = <fun>
val print_bool : bool -> unit = <fun>
val print_space : unit -> unit = <fun>
val print_cut : unit -> unit = <fun>
val print_break : int -> int -> unit = <fun>
val print_flush : unit -> unit = <fun>
val print_newline : unit -> unit = <fun>
val force_newline : unit -> unit = <fun>
val print_if_newline : unit -> unit = <fun>
val set_margin : int -> unit = <fun>
val get_margin : unit -> int = <fun>
val set_max_indent : int -> unit = <fun>
val get_max_indent : unit -> int = <fun>
val set_max_boxes : int -> unit = <fun>
val get_max_boxes : unit -> int = <fun>
val over_max_boxes : unit -> bool = <fun>
val open_hbox : unit -> unit = <fun>
val open_vbox : int -> unit = <fun>
val open_hvbox : int -> unit = <fun>
val open_hovbox : int -> unit = <fun>
val open_tbox : unit -> unit = <fun>
val close_tbox : unit -> unit = <fun>
val print_tbreak : int -> int -> unit = <fun>
val set_tab : unit -> unit = <fun>
val print_tab : unit -> unit = <fun>
val set_ellipsis_text : string -> unit = <fun>
val get_ellipsis_text : unit -> string = <fun>
type tag = string
val open_tag : tag -> unit = <fun>
val close_tag : unit -> unit = <fun>
val set_tags : bool -> unit = <fun>
val set_print_tags : bool -> unit = <fun>
val set_mark_tags : bool -> unit = <fun>
val get_print_tags : unit -> bool = <fun>
val get_mark_tags : unit -> bool = <fun>
val set_formatter_out_channel : out_channel -> unit = <fun>
val set_formatter_output_functions :
  (string -> int -> int -> unit) -> (unit -> unit) -> unit = <fun>
val get_formatter_output_functions :
  unit -> (string -> int -> int -> unit) * (unit -> unit) = <fun>
type formatter_tag_functions =
  Format.formatter_tag_functions = {
  mark_open_tag : tag -> string;
  mark_close_tag : tag -> string;
  print_open_tag : tag -> unit;
  print_close_tag : tag -> unit;
}
val set_formatter_tag_functions : formatter_tag_functions -> unit =
  <fun>
val get_formatter_tag_functions : unit -> formatter_tag_functions =
  <fun>
val set_all_formatter_output_functions :
  out:(string -> int -> int -> unit) ->
  flush:(unit -> unit) ->
  newline:(unit -> unit) -> spaces:(int -> unit) -> unit = <fun>
val get_all_formatter_output_functions :
  unit ->
  (string -> int -> int -> unit) * (unit -> unit) * (unit -> unit) *
  (int -> unit) = <fun>
type formatter = Format.formatter
val formatter_of_out_channel : out_channel -> formatter = <fun>
val std_formatter : formatter = <abstr>
val err_formatter : formatter = <abstr>
val formatter_of_buffer : Buffer.t -> formatter = <fun>
val stdbuf : Buffer.t = <abstr>
val str_formatter : formatter = <abstr>
val flush_str_formatter : unit -> string = <fun>
val make_formatter :
  (string -> int -> int -> unit) -> (unit -> unit) -> formatter = <fun>
val pp_open_hbox : formatter -> unit -> unit = <fun>
val pp_open_vbox : formatter -> int -> unit = <fun>
val pp_open_hvbox : formatter -> int -> unit = <fun>
val pp_open_hovbox : formatter -> int -> unit = <fun>
val pp_open_box : formatter -> int -> unit = <fun>
val pp_close_box : formatter -> unit -> unit = <fun>
val pp_open_tag : formatter -> string -> unit = <fun>
val pp_close_tag : formatter -> unit -> unit = <fun>
val pp_print_string : formatter -> string -> unit = <fun>
val pp_print_as : formatter -> int -> string -> unit = <fun>
val pp_print_int : formatter -> int -> unit = <fun>
val pp_print_float : formatter -> float -> unit = <fun>
val pp_print_char : formatter -> char -> unit = <fun>
val pp_print_bool : formatter -> bool -> unit = <fun>
val pp_print_break : formatter -> int -> int -> unit = <fun>
val pp_print_cut : formatter -> unit -> unit = <fun>
val pp_print_space : formatter -> unit -> unit = <fun>
val pp_force_newline : formatter -> unit -> unit = <fun>
val pp_print_flush : formatter -> unit -> unit = <fun>
val pp_print_newline : formatter -> unit -> unit = <fun>
val pp_print_if_newline : formatter -> unit -> unit = <fun>
val pp_open_tbox : formatter -> unit -> unit = <fun>
val pp_close_tbox : formatter -> unit -> unit = <fun>
val pp_print_tbreak : formatter -> int -> int -> unit = <fun>
val pp_set_tab : formatter -> unit -> unit = <fun>
val pp_print_tab : formatter -> unit -> unit = <fun>
val pp_set_tags : formatter -> bool -> unit = <fun>
val pp_set_print_tags : formatter -> bool -> unit = <fun>
val pp_set_mark_tags : formatter -> bool -> unit = <fun>
val pp_get_print_tags : formatter -> unit -> bool = <fun>
val pp_get_mark_tags : formatter -> unit -> bool = <fun>
val pp_set_margin : formatter -> int -> unit = <fun>
val pp_get_margin : formatter -> unit -> int = <fun>
val pp_set_max_indent : formatter -> int -> unit = <fun>
val pp_get_max_indent : formatter -> unit -> int = <fun>
val pp_set_max_boxes : formatter -> int -> unit = <fun>
val pp_get_max_boxes : formatter -> unit -> int = <fun>
val pp_over_max_boxes : formatter -> unit -> bool = <fun>
val pp_set_ellipsis_text : formatter -> string -> unit = <fun>
val pp_get_ellipsis_text : formatter -> unit -> string = <fun>
val pp_set_formatter_out_channel : formatter -> out_channel -> unit =
  <fun>
val pp_set_formatter_output_functions :
  formatter -> (string -> int -> int -> unit) -> (unit -> unit) -> unit =
  <fun>
val pp_get_formatter_output_functions :
  formatter -> unit -> (string -> int -> int -> unit) * (unit -> unit) =
  <fun>
val pp_set_all_formatter_output_functions :
  formatter ->
  out:(string -> int -> int -> unit) ->
  flush:(unit -> unit) ->
  newline:(unit -> unit) -> spaces:(int -> unit) -> unit = <fun>
val pp_get_all_formatter_output_functions :
  formatter ->
  unit ->
  (string -> int -> int -> unit) * (unit -> unit) * (unit -> unit) *
  (int -> unit) = <fun>
val pp_set_formatter_tag_functions :
  formatter -> formatter_tag_functions -> unit = <fun>
val pp_get_formatter_tag_functions :
  formatter -> unit -> formatter_tag_functions = <fun>
val fprintf : formatter -> ('a, formatter, unit) format -> 'a = <fun>
val printf : ('a, formatter, unit) format -> 'a = <fun>
val eprintf : ('a, formatter, unit) format -> 'a = <fun>
val sprintf : ('a, unit, string) format -> 'a = <fun>
val bprintf : Buffer.t -> ('a, formatter, unit) format -> 'a = <fun>
val kfprintf :
  (formatter -> 'a) ->
  formatter -> ('b, formatter, unit, 'a) format4 -> 'b = <fun>
val ksprintf : (string -> 'a) -> ('b, unit, string, 'a) format4 -> 'b =
  <fun>
val kprintf : (string -> 'a) -> ('b, unit, string, 'a) format4 -> 'b =
  <fun>
type num =
  Num.num =
    Int of int
  | Big_int of Big_int.big_int
  | Ratio of Ratio.ratio
val ( +/ ) : num -> num -> num = <fun>
val add_num : num -> num -> num = <fun>
val minus_num : num -> num = <fun>
val ( -/ ) : num -> num -> num = <fun>
val sub_num : num -> num -> num = <fun>
val ( */ ) : num -> num -> num = <fun>
val mult_num : num -> num -> num = <fun>
val square_num : num -> num = <fun>
val ( // ) : num -> num -> num = <fun>
val div_num : num -> num -> num = <fun>
val quo_num : num -> num -> num = <fun>
val mod_num : num -> num -> num = <fun>
val ( **/ ) : num -> num -> num = <fun>
val power_num : num -> num -> num = <fun>
val abs_num : num -> num = <fun>
val succ_num : num -> num = <fun>
val pred_num : num -> num = <fun>
val incr_num : num ref -> unit = <fun>
val decr_num : num ref -> unit = <fun>
val is_integer_num : num -> bool = <fun>
val integer_num : num -> num = <fun>
val floor_num : num -> num = <fun>
val round_num : num -> num = <fun>
val ceiling_num : num -> num = <fun>
val sign_num : num -> int = <fun>
val ( =/ ) : num -> num -> bool = <fun>
val ( </ ) : num -> num -> bool = <fun>
val ( >/ ) : num -> num -> bool = <fun>
val ( <=/ ) : num -> num -> bool = <fun>
val ( >=/ ) : num -> num -> bool = <fun>
val ( <>/ ) : num -> num -> bool = <fun>
val eq_num : num -> num -> bool = <fun>
val lt_num : num -> num -> bool = <fun>
val le_num : num -> num -> bool = <fun>
val gt_num : num -> num -> bool = <fun>
val ge_num : num -> num -> bool = <fun>
val compare_num : num -> num -> int = <fun>
val max_num : num -> num -> num = <fun>
val min_num : num -> num -> num = <fun>
val string_of_num : num -> string = <fun>
val approx_num_fix : int -> num -> string = <fun>
val approx_num_exp : int -> num -> string = <fun>
val num_of_string : string -> num = <fun>
val int_of_num : num -> int = <fun>
val num_of_int : int -> num = <fun>
val nat_of_num : num -> Nat.nat = <fun>
val num_of_nat : Nat.nat -> num = <fun>
val num_of_big_int : Big_int.big_int -> num = <fun>
val big_int_of_num : num -> Big_int.big_int = <fun>
val ratio_of_num : num -> Ratio.ratio = <fun>
val num_of_ratio : Ratio.ratio -> num = <fun>
val float_of_num : num -> float = <fun>
val print_num : num -> unit = <fun>
- : dummy_interactive = START_INTERACTIVE
- : dummy_interactive = END_INTERACTIVE
val quotexpander : string -> string = <fun>
- : unit = ()
- : unit = ()
- : unit = ()
val open_box : int -> unit = <fun>
val close_box : unit -> unit = <fun>
val print_string : string -> unit = <fun>
val print_as : int -> string -> unit = <fun>
val print_int : int -> unit = <fun>
val print_float : float -> unit = <fun>
val print_char : char -> unit = <fun>
val print_bool : bool -> unit = <fun>
val print_space : unit -> unit = <fun>
val print_cut : unit -> unit = <fun>
val print_break : int -> int -> unit = <fun>
val print_flush : unit -> unit = <fun>
val print_newline : unit -> unit = <fun>
val force_newline : unit -> unit = <fun>
val print_if_newline : unit -> unit = <fun>
val set_margin : int -> unit = <fun>
val get_margin : unit -> int = <fun>
val set_max_indent : int -> unit = <fun>
val get_max_indent : unit -> int = <fun>
val set_max_boxes : int -> unit = <fun>
val get_max_boxes : unit -> int = <fun>
val over_max_boxes : unit -> bool = <fun>
val open_hbox : unit -> unit = <fun>
val open_vbox : int -> unit = <fun>
val open_hvbox : int -> unit = <fun>
val open_hovbox : int -> unit = <fun>
val open_tbox : unit -> unit = <fun>
val close_tbox : unit -> unit = <fun>
val print_tbreak : int -> int -> unit = <fun>
val set_tab : unit -> unit = <fun>
val print_tab : unit -> unit = <fun>
val set_ellipsis_text : string -> unit = <fun>
val get_ellipsis_text : unit -> string = <fun>
type tag = string
val open_tag : tag -> unit = <fun>
val close_tag : unit -> unit = <fun>
val set_tags : bool -> unit = <fun>
val set_print_tags : bool -> unit = <fun>
val set_mark_tags : bool -> unit = <fun>
val get_print_tags : unit -> bool = <fun>
val get_mark_tags : unit -> bool = <fun>
val set_formatter_out_channel : out_channel -> unit = <fun>
val set_formatter_output_functions :
  (string -> int -> int -> unit) -> (unit -> unit) -> unit = <fun>
val get_formatter_output_functions :
  unit -> (string -> int -> int -> unit) * (unit -> unit) = <fun>
type formatter_tag_functions =
  Format.formatter_tag_functions = {
  mark_open_tag : tag -> string;
  mark_close_tag : tag -> string;
  print_open_tag : tag -> unit;
  print_close_tag : tag -> unit;
}
val set_formatter_tag_functions : formatter_tag_functions -> unit =
  <fun>
val get_formatter_tag_functions : unit -> formatter_tag_functions =
  <fun>
val set_all_formatter_output_functions :
  out:(string -> int -> int -> unit) ->
  flush:(unit -> unit) ->
  newline:(unit -> unit) -> spaces:(int -> unit) -> unit = <fun>
val get_all_formatter_output_functions :
  unit ->
  (string -> int -> int -> unit) * (unit -> unit) * (unit -> unit) *
  (int -> unit) = <fun>
type formatter = Format.formatter
val formatter_of_out_channel : out_channel -> formatter = <fun>
val std_formatter : formatter = <abstr>
val err_formatter : formatter = <abstr>
val formatter_of_buffer : Buffer.t -> formatter = <fun>
val stdbuf : Buffer.t = <abstr>
val str_formatter : formatter = <abstr>
val flush_str_formatter : unit -> string = <fun>
val make_formatter :
  (string -> int -> int -> unit) -> (unit -> unit) -> formatter = <fun>
val pp_open_hbox : formatter -> unit -> unit = <fun>
val pp_open_vbox : formatter -> int -> unit = <fun>
val pp_open_hvbox : formatter -> int -> unit = <fun>
val pp_open_hovbox : formatter -> int -> unit = <fun>
val pp_open_box : formatter -> int -> unit = <fun>
val pp_close_box : formatter -> unit -> unit = <fun>
val pp_open_tag : formatter -> string -> unit = <fun>
val pp_close_tag : formatter -> unit -> unit = <fun>
val pp_print_string : formatter -> string -> unit = <fun>
val pp_print_as : formatter -> int -> string -> unit = <fun>
val pp_print_int : formatter -> int -> unit = <fun>
val pp_print_float : formatter -> float -> unit = <fun>
val pp_print_char : formatter -> char -> unit = <fun>
val pp_print_bool : formatter -> bool -> unit = <fun>
val pp_print_break : formatter -> int -> int -> unit = <fun>
val pp_print_cut : formatter -> unit -> unit = <fun>
val pp_print_space : formatter -> unit -> unit = <fun>
val pp_force_newline : formatter -> unit -> unit = <fun>
val pp_print_flush : formatter -> unit -> unit = <fun>
val pp_print_newline : formatter -> unit -> unit = <fun>
val pp_print_if_newline : formatter -> unit -> unit = <fun>
val pp_open_tbox : formatter -> unit -> unit = <fun>
val pp_close_tbox : formatter -> unit -> unit = <fun>
val pp_print_tbreak : formatter -> int -> int -> unit = <fun>
val pp_set_tab : formatter -> unit -> unit = <fun>
val pp_print_tab : formatter -> unit -> unit = <fun>
val pp_set_tags : formatter -> bool -> unit = <fun>
val pp_set_print_tags : formatter -> bool -> unit = <fun>
val pp_set_mark_tags : formatter -> bool -> unit = <fun>
val pp_get_print_tags : formatter -> unit -> bool = <fun>
val pp_get_mark_tags : formatter -> unit -> bool = <fun>
val pp_set_margin : formatter -> int -> unit = <fun>
val pp_get_margin : formatter -> unit -> int = <fun>
val pp_set_max_indent : formatter -> int -> unit = <fun>
val pp_get_max_indent : formatter -> unit -> int = <fun>
val pp_set_max_boxes : formatter -> int -> unit = <fun>
val pp_get_max_boxes : formatter -> unit -> int = <fun>
val pp_over_max_boxes : formatter -> unit -> bool = <fun>
val pp_set_ellipsis_text : formatter -> string -> unit = <fun>
val pp_get_ellipsis_text : formatter -> unit -> string = <fun>
val pp_set_formatter_out_channel : formatter -> out_channel -> unit =
  <fun>
val pp_set_formatter_output_functions :
  formatter -> (string -> int -> int -> unit) -> (unit -> unit) -> unit =
  <fun>
val pp_get_formatter_output_functions :
  formatter -> unit -> (string -> int -> int -> unit) * (unit -> unit) =
  <fun>
val pp_set_all_formatter_output_functions :
  formatter ->
  out:(string -> int -> int -> unit) ->
  flush:(unit -> unit) ->
  newline:(unit -> unit) -> spaces:(int -> unit) -> unit = <fun>
val pp_get_all_formatter_output_functions :
  formatter ->
  unit ->
  (string -> int -> int -> unit) * (unit -> unit) * (unit -> unit) *
  (int -> unit) = <fun>
val pp_set_formatter_tag_functions :
  formatter -> formatter_tag_functions -> unit = <fun>
val pp_get_formatter_tag_functions :
  formatter -> unit -> formatter_tag_functions = <fun>
val fprintf : formatter -> ('a, formatter, unit) format -> 'a = <fun>
val printf : ('a, formatter, unit) format -> 'a = <fun>
val eprintf : ('a, formatter, unit) format -> 'a = <fun>
val sprintf : ('a, unit, string) format -> 'a = <fun>
val bprintf : Buffer.t -> ('a, formatter, unit) format -> 'a = <fun>
val kfprintf :
  (formatter -> 'a) ->
  formatter -> ('b, formatter, unit, 'a) format4 -> 'b = <fun>
val ksprintf : (string -> 'a) -> ('b, unit, string, 'a) format4 -> 'b =
  <fun>
val kprintf : (string -> 'a) -> ('b, unit, string, 'a) format4 -> 'b =
  <fun>
type num =
  Num.num =
    Int of int
  | Big_int of Big_int.big_int
  | Ratio of Ratio.ratio
val ( +/ ) : num -> num -> num = <fun>
val add_num : num -> num -> num = <fun>
val minus_num : num -> num = <fun>
val ( -/ ) : num -> num -> num = <fun>
val sub_num : num -> num -> num = <fun>
val ( */ ) : num -> num -> num = <fun>
val mult_num : num -> num -> num = <fun>
val square_num : num -> num = <fun>
val ( // ) : num -> num -> num = <fun>
val div_num : num -> num -> num = <fun>
val quo_num : num -> num -> num = <fun>
val mod_num : num -> num -> num = <fun>
val ( **/ ) : num -> num -> num = <fun>
val power_num : num -> num -> num = <fun>
val abs_num : num -> num = <fun>
val succ_num : num -> num = <fun>
val pred_num : num -> num = <fun>
val incr_num : num ref -> unit = <fun>
val decr_num : num ref -> unit = <fun>
val is_integer_num : num -> bool = <fun>
val integer_num : num -> num = <fun>
val floor_num : num -> num = <fun>
val round_num : num -> num = <fun>
val ceiling_num : num -> num = <fun>
val sign_num : num -> int = <fun>
val ( =/ ) : num -> num -> bool = <fun>
val ( </ ) : num -> num -> bool = <fun>
val ( >/ ) : num -> num -> bool = <fun>
val ( <=/ ) : num -> num -> bool = <fun>
val ( >=/ ) : num -> num -> bool = <fun>
val ( <>/ ) : num -> num -> bool = <fun>
val eq_num : num -> num -> bool = <fun>
val lt_num : num -> num -> bool = <fun>
val le_num : num -> num -> bool = <fun>
val gt_num : num -> num -> bool = <fun>
val ge_num : num -> num -> bool = <fun>
val compare_num : num -> num -> int = <fun>
val max_num : num -> num -> num = <fun>
val min_num : num -> num -> num = <fun>
val string_of_num : num -> string = <fun>
val approx_num_fix : int -> num -> string = <fun>
val approx_num_exp : int -> num -> string = <fun>
val num_of_string : string -> num = <fun>
val int_of_num : num -> int = <fun>
val num_of_int : int -> num = <fun>
val nat_of_num : num -> Nat.nat = <fun>
val num_of_nat : Nat.nat -> num = <fun>
val num_of_big_int : Big_int.big_int -> num = <fun>
val big_int_of_num : num -> Big_int.big_int = <fun>
val ratio_of_num : num -> Ratio.ratio = <fun>
val num_of_ratio : Ratio.ratio -> num = <fun>
val float_of_num : num -> float = <fun>
val print_num : num -> unit = <fun>
val identity : 'a -> 'a = <fun>
val ( ** ) : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b = <fun>
val gcd_num : num -> num -> num = <fun>
val lcm_num : num -> num -> num = <fun>
val non : ('a -> bool) -> 'a -> bool = <fun>
val check : ('a -> bool) -> 'a -> 'a = <fun>
val funpow : int -> ('a -> 'a) -> 'a -> 'a = <fun>
val can : ('a -> 'b) -> 'a -> bool = <fun>
val repeat : ('a -> 'a) -> 'a -> 'a = <fun>
val ( -- ) : int -> int -> int list = <fun>
val ( --- ) : num -> num -> num list = <fun>
val map2 : ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list = <fun>
val rev : 'a list -> 'a list = <fun>
val hd : 'a list -> 'a = <fun>
val tl : 'a list -> 'a list = <fun>
val itlist : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b = <fun>
val end_itlist : ('a -> 'a -> 'a) -> 'a list -> 'a = <fun>
val itlist2 : ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c =
  <fun>
val zip : 'a list -> 'b list -> ('a * 'b) list = <fun>
val forall : ('a -> bool) -> 'a list -> bool = <fun>
val exists : ('a -> bool) -> 'a list -> bool = <fun>
val partition : ('a -> bool) -> 'a list -> 'a list * 'a list = <fun>
val filter : ('a -> bool) -> 'a list -> 'a list = <fun>
val length : 'a list -> int = <fun>
val last : 'a list -> 'a = <fun>
val butlast : 'a list -> 'a list = <fun>
val find : ('a -> bool) -> 'a list -> 'a = <fun>
val el : int -> 'a list -> 'a = <fun>
val map : ('a -> 'b) -> 'a list -> 'b list = <fun>
val allpairs : ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list =
  <fun>
val distinctpairs : 'a list -> ('a * 'a) list = <fun>
val chop_list : int -> 'a list -> 'a list * 'a list = <fun>
val replicate : int -> 'a -> 'a list = <fun>
val insertat : int -> 'a -> 'a list -> 'a list = <fun>
val forall2 : ('a -> 'b -> bool) -> 'a list -> 'b list -> bool = <fun>
val index : 'a -> 'a list -> int = <fun>
val unzip : ('a * 'b) list -> 'a list * 'b list = <fun>
val earlier : 'a list -> 'a -> 'a -> bool = <fun>
val do_list : ('a -> 'b) -> 'a list -> unit = <fun>
val assoc : 'a -> ('a * 'b) list -> 'b = <fun>
val rev_assoc : 'a -> ('b * 'a) list -> 'b = <fun>
val merge : ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list = <fun>
val sort : ('a -> 'a -> bool) -> 'a list -> 'a list = <fun>
val increasing : ('a -> 'b) -> 'a -> 'a -> bool = <fun>
val decreasing : ('a -> 'b) -> 'a -> 'a -> bool = <fun>
val uniq : 'a list -> 'a list = <fun>
val repetitions : 'a list -> ('a * int) list = <fun>
val tryfind : ('a -> 'b) -> 'a list -> 'b = <fun>
val mapfilter : ('a -> 'b) -> 'a list -> 'b list = <fun>
val optimize : ('a -> 'a -> bool) -> ('b -> 'a) -> 'b list -> 'b =
  <fun>
val maximize : ('a -> 'b) -> 'a list -> 'a = <fun>
val minimize : ('a -> 'b) -> 'a list -> 'a = <fun>
val setify : 'a list -> 'a list = <fun>
val union : 'a list -> 'a list -> 'a list = <fun>
val intersect : 'a list -> 'a list -> 'a list = <fun>
val subtract : 'a list -> 'a list -> 'a list = <fun>
val subset : 'a list -> 'a list -> bool = <fun>
val psubset : 'a list -> 'a list -> bool = <fun>
val set_eq : 'a list -> 'a list -> bool = <fun>
val insert : 'a -> 'a list -> 'a list = <fun>
val image : ('a -> 'b) -> 'a list -> 'b list = <fun>
val unions : 'a list list -> 'a list = <fun>
val mem : 'a -> 'a list -> bool = <fun>
val allsets : int -> 'a list -> 'a list list = <fun>
val allsubsets : 'a list -> 'a list list = <fun>
val allnonemptysubsets : 'a list -> 'a list list = <fun>
val explode : string -> string list = <fun>
val implode : string list -> string = <fun>
val time : ('a -> 'b) -> 'a -> 'b = <fun>
type ('a, 'b) func =
    Empty
  | Leaf of int * ('a * 'b) list
  | Branch of int * int * ('a, 'b) func * ('a, 'b) func
val undefined : ('a, 'b) func = Empty
val is_undefined : ('a, 'b) func -> bool = <fun>
val mapf : ('a -> 'b) -> ('c, 'a) func -> ('c, 'b) func = <fun>
val foldl : ('a -> 'b -> 'c -> 'a) -> 'a -> ('b, 'c) func -> 'a = <fun>
val foldr : ('a -> 'b -> 'c -> 'c) -> ('a, 'b) func -> 'c -> 'c = <fun>
val graph : ('a, 'b) func -> ('a * 'b) list = <fun>
val dom : ('a, 'b) func -> 'a list = <fun>
val ran : ('a, 'b) func -> 'b list = <fun>
val applyd : ('a, 'b) func -> ('a -> 'b) -> 'a -> 'b = <fun>
val apply : ('a, 'b) func -> 'a -> 'b = <fun>
val tryapplyd : ('a, 'b) func -> 'a -> 'b -> 'b = <fun>
val tryapplyl : ('a, 'b list) func -> 'a -> 'b list = <fun>
val defined : ('a, 'b) func -> 'a -> bool = <fun>
val undefine : 'a -> ('a, 'b) func -> ('a, 'b) func = <fun>
val ( |-> ) : 'a -> 'b -> ('a, 'b) func -> ('a, 'b) func = <fun>
val combine :
  ('a -> 'a -> 'a) ->
  ('a -> bool) -> ('b, 'a) func -> ('b, 'a) func -> ('b, 'a) func =
  <fun>
val ( |=> ) : 'a -> 'b -> ('a, 'b) func = <fun>
val fpf : 'a list -> 'b list -> ('a, 'b) func = <fun>
val choose : ('a, 'b) func -> 'a * 'b = <fun>
val print_fpf : ('a, 'b) func -> unit = <fun>
val valmod : 'a -> 'b -> ('a -> 'b) -> 'a -> 'b = <fun>
val undef : 'a -> 'b = <fun>
type 'a pnode = Nonterminal of 'a | Terminal of 'a * int
type 'a partition = Partition of ('a, 'a pnode) func
val terminus : 'a partition -> 'a -> 'a * int = <fun>
val tryterminus : 'a partition -> 'a -> 'a * int = <fun>
val canonize : 'a partition -> 'a -> 'a = <fun>
val equivalent : 'a partition -> 'a -> 'a -> bool = <fun>
val equate : 'a * 'a -> 'a partition -> 'a partition = <fun>
val unequal : 'a partition = Partition <func>
val equated : 'a partition -> 'a list = <fun>
val first : num -> (num -> bool) -> num = <fun>
type expression =
    Var of string
  | Const of int
  | Add of expression * expression
  | Mul of expression * expression
val simplify1 : expression -> expression = <fun>
val simplify : expression -> expression = <fun>
val matches : string -> string -> bool = <fun>
val space : string -> bool = <fun>
val punctuation : string -> bool = <fun>
val symbolic : string -> bool = <fun>
val numeric : string -> bool = <fun>
val alphanumeric : string -> bool = <fun>
val lexwhile : (string -> bool) -> string list -> string * string list =
  <fun>
val lex : string list -> string list = <fun>
val parse_expression : string list -> expression * string list = <fun>
val parse_product : string list -> expression * string list = <fun>
val parse_atom : string list -> expression * string list = <fun>
val make_parser : (string list -> 'a * 'b list) -> string -> 'a = <fun>
val default_parser : string -> expression = <fun>
val string_of_exp : expression -> string = <fun>
val string_of_exp : int -> expression -> string = <fun>
val print_exp : expression -> unit = <fun>
type 'a formula =
    False
  | True
  | Atom of 'a
  | Not of 'a formula
  | And of 'a formula * 'a formula
  | Or of 'a formula * 'a formula
  | Imp of 'a formula * 'a formula
  | Iff of 'a formula * 'a formula
  | Forall of string * 'a formula
  | Exists of string * 'a formula
val parse_ginfix :
  'a ->
  (('b -> 'c) -> 'b -> 'b -> 'c) ->
  ('b -> 'c) -> ('a list -> 'b * 'a list) -> 'a list -> 'c * 'a list =
  <fun>
val parse_left_infix :
  'a ->
  ('b * 'b -> 'b) ->
  ('a list -> 'b * 'a list) -> 'a list -> 'b * 'a list = <fun>
val parse_right_infix :
  'a ->
  ('b * 'b -> 'b) ->
  ('a list -> 'b * 'a list) -> 'a list -> 'b * 'a list = <fun>
val parse_list :
  'a -> ('a list -> 'b * 'a list) -> 'a list -> 'b list * 'a list =
  <fun>
val papply : ('a -> 'b) -> 'a * 'c -> 'b * 'c = <fun>
val nextin : 'a list -> 'a -> bool = <fun>
val parse_bracketed : ('a -> 'b * 'c list) -> 'c -> 'a -> 'b * 'c list =
  <fun>
val parse_atomic_formula :
  (string list -> string list -> 'a formula * string list) *
  (string list -> string list -> 'a formula * string list) ->
  string list -> string list -> 'a formula * string list = <fun>
val parse_quant :
  (string list -> string list -> 'a formula * string list) *
  (string list -> string list -> 'a formula * string list) ->
  string list ->
  (string * 'a formula -> 'a formula) ->
  string -> string list -> 'a formula * string list = <fun>
val parse_formula :
  (string list -> string list -> 'a formula * string list) *
  (string list -> string list -> 'a formula * string list) ->
  string list -> string list -> 'a formula * string list = <fun>
val bracket : bool -> int -> ('a -> 'b -> 'c) -> 'a -> 'b -> unit =
  <fun>
val strip_quant : 'a formula -> string list * 'a formula = <fun>
val print_formula : (int -> 'a -> unit) -> 'a formula -> unit = <fun>
val print_qformula : (int -> 'a -> unit) -> 'a formula -> unit = <fun>
val mk_and : 'a formula -> 'a formula -> 'a formula = <fun>
val mk_or : 'a formula -> 'a formula -> 'a formula = <fun>
val mk_imp : 'a formula -> 'a formula -> 'a formula = <fun>
val mk_iff : 'a formula -> 'a formula -> 'a formula = <fun>
val mk_forall : string -> 'a formula -> 'a formula = <fun>
val mk_exists : string -> 'a formula -> 'a formula = <fun>
val dest_iff : 'a formula -> 'a formula * 'a formula = <fun>
val dest_and : 'a formula -> 'a formula * 'a formula = <fun>
val conjuncts : 'a formula -> 'a formula list = <fun>
val dest_or : 'a formula -> 'a formula * 'a formula = <fun>
val disjuncts : 'a formula -> 'a formula list = <fun>
val dest_imp : 'a formula -> 'a formula * 'a formula = <fun>
val antecedent : 'a formula -> 'a formula = <fun>
val consequent : 'a formula -> 'a formula = <fun>
val onatoms : ('a -> 'a formula) -> 'a formula -> 'a formula = <fun>
val overatoms : ('a -> 'b -> 'b) -> 'a formula -> 'b -> 'b = <fun>
val atom_union : ('a -> 'b list) -> 'a formula -> 'b list = <fun>
type prop = P of string
val pname : prop -> string = <fun>
val parse_propvar : 'a -> string list -> prop formula * string list =
  <fun>
val parse_prop_formula : string -> prop formula = <fun>
val default_parser : string -> prop formula = <fun>
val print_propvar : 'a -> prop -> unit = <fun>
val print_prop_formula : prop formula -> unit = <fun>
File "atp_interactive.ml", line 1199, characters 2-263:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Exists (_, _)|Forall (_, _))
val eval : 'a formula -> ('a -> bool) -> bool = <fun>
val atoms : 'a formula -> 'a list = <fun>
val onallvaluations :
  (('a -> bool) -> bool) -> ('a -> bool) -> 'a list -> bool = <fun>
val print_truthtable : prop formula -> unit = <fun>
val tautology : 'a formula -> bool = <fun>
val unsatisfiable : 'a formula -> bool = <fun>
val satisfiable : 'a formula -> bool = <fun>
val psubst : ('a, 'a formula) func -> 'a formula -> 'a formula = <fun>
val dual : 'a formula -> 'a formula = <fun>
val psimplify1 : 'a formula -> 'a formula = <fun>
val psimplify : 'a formula -> 'a formula = <fun>
val negative : 'a formula -> bool = <fun>
val positive : 'a formula -> bool = <fun>
val negate : 'a formula -> 'a formula = <fun>
val nnf : 'a formula -> 'a formula = <fun>
val nnf : 'a formula -> 'a formula = <fun>
val nenf : 'a formula -> 'a formula = <fun>
val nenf : 'a formula -> 'a formula = <fun>
val list_conj : 'a formula list -> 'a formula = <fun>
val list_disj : 'a formula list -> 'a formula = <fun>
val mk_lits : 'a formula list -> ('a -> bool) -> 'a formula = <fun>
val allsatvaluations :
  (('a -> bool) -> bool) ->
  ('a -> bool) -> 'a list -> ('a -> bool) list = <fun>
val dnf : 'a formula -> 'a formula = <fun>
val distrib : 'a formula -> 'a formula = <fun>
val rawdnf : 'a formula -> 'a formula = <fun>
val distrib : 'a list list -> 'a list list -> 'a list list = <fun>
val purednf : 'a formula -> 'a formula list list = <fun>
val trivial : 'a formula list -> bool = <fun>
val simpdnf : 'a formula -> 'a formula list list = <fun>
val dnf : 'a formula -> 'a formula = <fun>
val purecnf : 'a formula -> 'a formula list list = <fun>
val simpcnf : 'a formula -> 'a formula list list = <fun>
val cnf : 'a formula -> 'a formula = <fun>
File "atp_interactive.ml", line 1649, characters 6-7:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ramsey : int -> int -> int -> prop formula = <fun>
val halfsum : 'a formula -> 'a formula -> 'a formula = <fun>
val halfcarry : 'a formula -> 'a formula -> 'a formula = <fun>
val ha :
  'a formula -> 'a formula -> 'a formula -> 'a formula -> 'a formula =
  <fun>
val carry : 'a formula -> 'a formula -> 'a formula -> 'a formula =
  <fun>
val sum : 'a formula -> 'a formula -> 'a formula -> 'a formula = <fun>
val fa :
  'a formula ->
  'a formula -> 'a formula -> 'a formula -> 'a formula -> 'a formula =
  <fun>
val conjoin : ('a -> 'b formula) -> 'a list -> 'b formula = <fun>
val ripplecarry :
  (int -> 'a formula) ->
  (int -> 'a formula) ->
  (int -> 'a formula) -> (int -> 'a formula) -> int -> 'a formula =
  <fun>
val mk_index : string -> int -> prop formula = <fun>
val mk_index2 : string -> int -> int -> prop formula = <fun>
val ripplecarry0 :
  (int -> 'a formula) ->
  (int -> 'a formula) ->
  (int -> 'a formula) -> (int -> 'a formula) -> int -> 'a formula =
  <fun>
val ripplecarry1 :
  (int -> 'a formula) ->
  (int -> 'a formula) ->
  (int -> 'a formula) -> (int -> 'a formula) -> int -> 'a formula =
  <fun>
val mux : 'a formula -> 'a formula -> 'a formula -> 'a formula = <fun>
val offset : int -> (int -> 'a) -> int -> 'a = <fun>
val carryselect :
  (int -> 'a formula) ->
  (int -> 'a formula) ->
  (int -> 'a formula) ->
  (int -> 'a formula) ->
  (int -> 'a formula) ->
  (int -> 'a formula) ->
  (int -> 'a formula) ->
  (int -> 'a formula) -> int -> int -> 'a formula = <fun>
File "atp_interactive.ml", line 1754, characters 6-42:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val mk_adder_test : int -> int -> prop formula = <fun>
val rippleshift :
  (int -> 'a formula) ->
  (int -> 'a formula) ->
  (int -> 'a formula) ->
  'a formula -> (int -> 'a formula) -> int -> 'a formula = <fun>
val multiplier :
  (int -> int -> 'a formula) ->
  (int -> int -> 'a formula) ->
  (int -> int -> 'a formula) ->
  (int -> 'a formula) -> int -> 'a formula = <fun>
val bitlength : int -> int = <fun>
val bit : int -> int -> bool = <fun>
val congruent_to : (int -> 'a formula) -> int -> int -> 'a formula =
  <fun>
File "atp_interactive.ml", line 1805, characters 6-17:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
File "atp_interactive.ml", line 1807, characters 6-12:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val prime : int -> prop formula = <fun>
val mkprop : num -> prop formula * num = <fun>
val maincnf :
  prop formula * (prop formula, prop formula * prop formula) func * num ->
  prop formula * (prop formula, prop formula * prop formula) func * num =
  <fun>
val defstep :
  (prop formula -> prop formula -> prop formula) ->
  prop formula * prop formula ->
  prop formula * (prop formula, prop formula * prop formula) func * num ->
  prop formula * (prop formula, prop formula * prop formula) func * num =
  <fun>
val max_varindex : string -> string -> num -> num = <fun>
val mk_defcnf :
  (prop formula * ('a, 'b) func * num ->
   'c formula * ('d, 'e * 'c formula) func * 'f) ->
  prop formula -> 'c formula list list = <fun>
val defcnf : prop formula -> prop formula = <fun>
val subcnf :
  ('a * 'b * 'c -> 'd * 'b * 'c) ->
  ('d -> 'd -> 'e) -> 'a * 'a -> 'f * 'b * 'c -> 'e * 'b * 'c = <fun>
val orcnf :
  prop formula * (prop formula, prop formula * prop formula) func * num ->
  prop formula * (prop formula, prop formula * prop formula) func * num =
  <fun>
val andcnf :
  prop formula * (prop formula, prop formula * prop formula) func * num ->
  prop formula * (prop formula, prop formula * prop formula) func * num =
  <fun>
val defcnfs : prop formula -> prop formula list list = <fun>
val defcnf : prop formula -> prop formula = <fun>
val andcnf3 :
  prop formula * (prop formula, prop formula * prop formula) func * num ->
  prop formula * (prop formula, prop formula * prop formula) func * num =
  <fun>
val defcnf3 : prop formula -> prop formula = <fun>
val one_literal_rule : 'a formula list list -> 'a formula list list =
  <fun>
val affirmative_negative_rule :
  'a formula list list -> 'a formula list list = <fun>
val resolve_on :
  'a formula -> 'a formula list list -> 'a formula list list = <fun>
val resolution_blowup : 'a formula list list -> 'a formula -> int =
  <fun>
val resolution_rule : 'a formula list list -> 'a formula list list =
  <fun>
val dp : 'a formula list list -> bool = <fun>
val dpsat : prop formula -> bool = <fun>
val dptaut : prop formula -> bool = <fun>
val posneg_count : 'a formula list list -> 'a formula -> int = <fun>
val dpll : 'a formula list list -> bool = <fun>
val dpllsat : prop formula -> bool = <fun>
val dplltaut : prop formula -> bool = <fun>
type trailmix = Guessed | Deduced
val unassigned :
  'a formula list list -> ('a formula * 'b) list -> 'a formula list =
  <fun>
val unit_subpropagate :
  'a formula list list * ('a formula, unit) func *
  ('a formula * trailmix) list ->
  'a formula list list * ('a formula, unit) func *
  ('a formula * trailmix) list = <fun>
val unit_propagate :
  'a formula list list * ('a formula * trailmix) list ->
  'a formula list list * ('a formula * trailmix) list = <fun>
val backtrack : ('a * trailmix) list -> ('a * trailmix) list = <fun>
val dpli : 'a formula list list -> ('a formula * trailmix) list -> bool =
  <fun>
val dplisat : prop formula -> bool = <fun>
val dplitaut : prop formula -> bool = <fun>
val backjump :
  'a formula list list ->
  'a formula ->
  ('a formula * trailmix) list -> ('a formula * trailmix) list = <fun>
val dplb : 'a formula list list -> ('a formula * trailmix) list -> bool =
  <fun>
val dplbsat : prop formula -> bool = <fun>
val dplbtaut : prop formula -> bool = <fun>
val triplicate : prop formula -> prop formula * prop formula list =
  <fun>
val atom : 'a formula -> 'a formula = <fun>
val align : 'a formula * 'a formula -> 'a formula * 'a formula = <fun>
val equate2 :
  'a formula * 'a formula ->
  'a formula partition -> 'a formula partition = <fun>
val irredundant :
  'a formula partition ->
  ('a formula * 'a formula) list -> ('a formula * 'a formula) list =
  <fun>
val consequences :
  'a formula * 'a formula ->
  'a formula ->
  ('a formula * 'a formula) list -> ('a formula * 'a formula) list =
  <fun>
val triggers :
  'a formula ->
  (('a formula * 'a formula) * ('a formula * 'a formula) list) list =
  <fun>
File "atp_interactive.ml", line 2179, characters 6-7:
Warning Y: unused variable p.
File "atp_interactive.ml", line 2179, characters 20-21:
Warning Y: unused variable q.
File "atp_interactive.ml", line 2179, characters 34-35:
Warning Y: unused variable r.
File "atp_interactive.ml", line 2176, characters 6-45:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
File "atp_interactive.ml", line 2181, characters 6-13:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
File "atp_interactive.ml", line 2187, characters 2-245:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Exists (_, _)|Forall (_, _)|Imp (_, _)|Or (_, _)|And (_, _)|Not _|Atom _|
True|False)
val trigger :
  prop formula ->
  ((prop formula * prop formula) * (prop formula * prop formula) list)
  list = <fun>
val relevance :
  (('a * 'a) * 'b) list -> ('a, (('a * 'a) * 'b) list) func = <fun>
val equatecons :
  'a formula * 'a formula ->
  'a formula partition * ('a formula, ('b * 'c list) list) func ->
  'c list *
  ('a formula partition * ('a formula, ('b * 'c list) list) func) =
  <fun>
val zero_saturate :
  'a formula partition *
  ('a formula, ('b * ('a formula * 'a formula) list) list) func ->
  ('a formula * 'a formula) list ->
  'a formula partition *
  ('a formula, ('b * ('a formula * 'a formula) list) list) func = <fun>
val zero_saturate_and_check :
  'a formula partition *
  ('a formula, ('b * ('a formula * 'a formula) list) list) func ->
  ('a formula * 'a formula) list ->
  'a formula partition *
  ('a formula, ('b * ('a formula * 'a formula) list) list) func = <fun>
val truefalse : 'a formula partition -> bool = <fun>
val equateset :
  'a formula list ->
  'a formula partition * ('a formula, ('b * 'c list) list) func ->
  'a formula partition * ('a formula, ('b * 'c list) list) func = <fun>
val inter :
  'a formula list ->
  'a formula partition * 'b ->
  'a formula partition * 'c ->
  ('a formula, 'a formula list) func ->
  ('a formula, 'a formula list) func ->
  'a formula partition * ('a formula, ('d * 'e list) list) func ->
  'a formula partition * ('a formula, ('d * 'e list) list) func = <fun>
val reverseq : 'a list -> 'a partition -> ('a, 'a list) func = <fun>
val stal_intersect :
  'a formula partition * ('a formula, ('b * 'c list) list) func ->
  'a formula partition * ('a formula, ('b * 'c list) list) func ->
  'a formula partition * ('a formula, ('b * 'c list) list) func ->
  'a formula partition * ('a formula, ('b * 'c list) list) func = <fun>
val saturate :
  int ->
  'a formula partition *
  ('a formula, ('b * ('a formula * 'a formula) list) list) func ->
  ('a formula * 'a formula) list ->
  'a formula list ->
  'a formula partition *
  ('a formula, ('b * ('a formula * 'a formula) list) list) func = <fun>
val splits :
  int ->
  'a formula partition *
  ('a formula, ('b * ('a formula * 'a formula) list) list) func ->
  'a formula list ->
  'a formula list ->
  'a formula partition *
  ('a formula, ('b * ('a formula * 'a formula) list) list) func = <fun>
val saturate_upto :
  'a formula list ->
  int ->
  int ->
  (('a formula * 'a formula) * ('a formula * 'a formula) list) list ->
  ('a formula * 'a formula) list -> bool = <fun>
val stalmarck : prop formula -> bool = <fun>
type bddnode = prop * int * int
type bdd =
    Bdd of ((bddnode, int) func * (int, bddnode) func * int) *
      (prop -> prop -> bool)
val print_bdd : bdd -> unit = <fun>
val expand_node : bdd -> int -> bddnode = <fun>
val lookup_unique : bdd -> bddnode -> bdd * int = <fun>
val mk_node : bdd -> prop * int * int -> bdd * int = <fun>
val mk_bdd : (prop -> prop -> bool) -> bdd = <fun>
val order : bdd -> prop -> prop -> bool = <fun>
val thread :
  'a ->
  ('b -> 'c * 'd -> 'e) ->
  ('a -> 'f -> 'g * 'c) * 'f -> ('g -> 'h -> 'b * 'd) * 'h -> 'e =
  <fun>
val bdd_and :
  bdd * (int * int, int) func ->
  int * int -> (bdd * (int * int, int) func) * int = <fun>
val bdd_or :
  bdd * (int * int, int) func ->
  int * int -> (bdd * (int * int, int) func) * int = <fun>
val bdd_imp :
  bdd * (int * int, int) func ->
  int * int -> (bdd * (int * int, int) func) * int = <fun>
val bdd_iff :
  bdd * (int * int, int) func ->
  int * int -> (bdd * (int * int, int) func) * int = <fun>
File "atp_interactive.ml", line 2442, characters 2-423:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Exists (_, _)|Forall (_, _))
val mkbdd :
  bdd * (int * int, int) func ->
  prop formula -> (bdd * (int * int, int) func) * int = <fun>
val bddtaut : prop formula -> bool = <fun>
val dest_nimp : 'a formula -> 'a formula * 'a formula = <fun>
val dest_iffdef : 'a formula -> 'a * 'a formula = <fun>
val restore_iffdef : 'a * 'a formula -> 'a formula -> 'a formula =
  <fun>
val suitable_iffdef : ('a * 'b) list -> 'c * 'a formula -> bool = <fun>
val sort_defs :
  ('a * 'a formula) list ->
  ('a * 'a formula) list ->
  'a formula -> ('a * 'a formula) list * 'a formula = <fun>
File "atp_interactive.ml", line 2494, characters 2-528:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Exists (_, _)|Forall (_, _))
val mkbdde :
  (prop, int) func ->
  bdd * (int * int, int) func ->
  prop formula -> (bdd * (int * int, int) func) * int = <fun>
val mkbdds :
  (prop, int) func ->
  bdd * (int * int, int) func ->
  (prop * prop formula) list ->
  prop formula -> (bdd * (int * int, int) func) * int = <fun>
val ebddtaut : prop formula -> bool = <fun>
type term = Var of string | Fn of string * term list
type fol = R of string * term list
val onformula : (term -> term) -> fol formula -> fol formula = <fun>
val is_const_name : string -> bool = <fun>
val parse_atomic_term :
  string list -> string list -> term * string list = <fun>
val parse_term : string list -> string list -> term * string list =
  <fun>
val parset : string -> term = <fun>
val parse_infix_atom :
  string list -> string list -> fol formula * string list = <fun>
val parse_atom :
  string list -> string list -> fol formula * string list = <fun>
val parse : string -> fol formula = <fun>
val default_parser : string -> fol formula = <fun>
val secondary_parser : string -> term = <fun>
val print_term : int -> term -> unit = <fun>
val print_fargs : string -> term list -> unit = <fun>
val print_infix_term :
  bool -> int -> int -> string -> term -> term -> unit = <fun>
val printert : term -> unit = <fun>
val print_atom : 'a -> fol -> unit = <fun>
val print_fol_formula : fol formula -> unit = <fun>
val termval :
  'a * (string -> 'b list -> 'b) * 'c ->
  (string, 'b) func -> term -> 'b = <fun>
val holds :
  'a list * (string -> 'a list -> 'a) * (string -> 'a list -> bool) ->
  (string, 'a) func -> fol formula -> bool = <fun>
val bool_interp :
  bool list * (string -> bool list -> bool) *
  (string -> 'a list -> bool) = ([false; true], <fun>, <fun>)
val mod_interp :
  int ->
  int list * (string -> int list -> int) * (string -> 'a list -> bool) =
  <fun>
val fvt : term -> string list = <fun>
val var : fol formula -> string list = <fun>
val fv : fol formula -> string list = <fun>
val generalize : fol formula -> fol formula = <fun>
val tsubst : (string, term) func -> term -> term = <fun>
val variant : string -> string list -> string = <fun>
val subst : (string, term) func -> fol formula -> fol formula = <fun>
val substq :
  (string, term) func ->
  (string -> fol formula -> fol formula) ->
  string -> fol formula -> fol formula = <fun>
val simplify1 : fol formula -> fol formula = <fun>
val simplify : fol formula -> fol formula = <fun>
val nnf : 'a formula -> 'a formula = <fun>
val pullquants : fol formula -> fol formula = <fun>
val pullq :
  bool * bool ->
  fol formula ->
  (string -> fol formula -> fol formula) ->
  (fol formula -> fol formula -> fol formula) ->
  string -> string -> fol formula -> fol formula -> fol formula = <fun>
val prenex : fol formula -> fol formula = <fun>
val pnf : fol formula -> fol formula = <fun>
val funcs : term -> (string * int) list = <fun>
val functions : fol formula -> (string * int) list = <fun>
val skolem : fol formula -> string list -> fol formula * string list =
  <fun>
val skolem2 :
  (fol formula * fol formula -> fol formula) ->
  fol formula * fol formula -> string list -> fol formula * string list =
  <fun>
val askolemize : fol formula -> fol formula = <fun>
val specialize : 'a formula -> 'a formula = <fun>
val skolemize : fol formula -> fol formula = <fun>
val pholds : ('a formula -> bool) -> 'a formula -> bool = <fun>
val herbfuns : fol formula -> (string * int) list * (string * int) list =
  <fun>
val groundterms : term list -> (string * int) list -> int -> term list =
  <fun>
val groundtuples :
  term list -> (string * int) list -> int -> int -> term list list =
  <fun>
val herbloop :
  ('a -> (fol formula -> fol formula) -> 'b list -> 'b list) ->
  ('b list -> bool) ->
  'a ->
  term list ->
  (string * int) list ->
  string list ->
  int -> 'b list -> term list list -> term list list -> term list list =
  <fun>
val gilmore_loop :
  fol formula list list ->
  term list ->
  (string * int) list ->
  string list ->
  int ->
  fol formula list list ->
  term list list -> term list list -> term list list = <fun>
val gilmore : fol formula -> int = <fun>
val dp_mfn : 'a list list -> ('a -> 'b) -> 'b list list -> 'b list list =
  <fun>
val dp_loop :
  fol formula list list ->
  term list ->
  (string * int) list ->
  string list ->
  int ->
  fol formula list list ->
  term list list -> term list list -> term list list = <fun>
val davisputnam : fol formula -> int = <fun>
val dp_refine :
  fol formula list list ->
  string list -> term list list -> term list list -> term list list =
  <fun>
val dp_refine_loop :
  fol formula list list ->
  term list ->
  (string * int) list ->
  string list ->
  int ->
  fol formula list list ->
  term list list -> term list list -> term list list = <fun>
val davisputnam' : fol formula -> int = <fun>
val istriv : (string, term) func -> string -> term -> bool = <fun>
val unify :
  (string, term) func -> (term * term) list -> (string, term) func =
  <fun>
val solve : (string, term) func -> (string, term) func = <fun>
val fullunify : (term * term) list -> (string, term) func = <fun>
val unify_and_apply : (term * term) list -> (term * term) list = <fun>
val unify_literals :
  (string, term) func ->
  fol formula * fol formula -> (string, term) func = <fun>
val unify_complements :
  (string, term) func ->
  fol formula * fol formula -> (string, term) func = <fun>
val unify_refute :
  fol formula list list -> (string, term) func -> (string, term) func =
  <fun>
val prawitz_loop :
  fol formula list list ->
  string list ->
  fol formula list list -> int -> (string, term) func * int = <fun>
val prawitz : fol formula -> int = <fun>
val compare : fol formula -> int * int = <fun>
val tableau :
  fol formula list * fol formula list * int ->
  ((string, term) func * int -> 'a) -> (string, term) func * int -> 'a =
  <fun>
val deepen : (int -> 'a) -> int -> 'a = <fun>
File "atp_interactive.ml", line 3403, characters 19-64:
Warning S: this expression should have type unit.
val tabrefute : fol formula list -> int = <fun>
val tab : fol formula -> int = <fun>
val splittab : fol formula -> int list = <fun>
val barb : fol formula =
  <<~(exists b. forall x. shaves(b,x) <=> ~shaves(x,x))>>
val mgu :
  fol formula list -> (string, term) func -> (string, term) func =
  <fun>
val unifiable : fol formula -> fol formula -> bool = <fun>
val rename : string -> fol formula list -> fol formula list = <fun>
val resolvents :
  fol formula list ->
  fol formula list ->
  fol formula -> fol formula list list -> fol formula list list = <fun>
val resolve_clauses :
  fol formula list -> fol formula list -> fol formula list list = <fun>
val resloop : fol formula list list * fol formula list list -> bool =
  <fun>
val pure_resolution : fol formula -> bool = <fun>
val resolution : fol formula -> bool list = <fun>
val term_match :
  (string, term) func -> (term * term) list -> (string, term) func =
  <fun>
val match_literals :
  (string, term) func ->
  fol formula * fol formula -> (string, term) func = <fun>
val subsumes_clause : fol formula list -> fol formula list -> bool =
  <fun>
val replace :
  fol formula list -> fol formula list list -> fol formula list list =
  <fun>
val incorporate :
  fol formula list ->
  fol formula list -> fol formula list list -> fol formula list list =
  <fun>
val resloop : fol formula list list * fol formula list list -> bool =
  <fun>
val pure_resolution : fol formula -> bool = <fun>
val resolution : fol formula -> bool list = <fun>
val presolve_clauses :
  fol formula list -> fol formula list -> fol formula list list = <fun>
val presloop : fol formula list list * fol formula list list -> bool =
  <fun>
val pure_presolution : fol formula -> bool = <fun>
val presolution : fol formula -> bool list = <fun>
val renamerule :
  int ->
  fol formula list * fol formula ->
  (fol formula list * fol formula) * int = <fun>
val backchain :
  (fol formula list * fol formula) list ->
  int ->
  int -> (string, term) func -> fol formula list -> (string, term) func =
  <fun>
val hornify : 'a formula list -> 'a formula list * 'a formula = <fun>
val hornprove : fol formula -> (string, term) func * int = <fun>
val parserule : string -> fol formula list * fol formula = <fun>
val simpleprolog : string list -> string -> (string, term) func = <fun>
val prolog : string list -> string -> fol formula list = <fun>
val contrapositives :
  'a formula list -> ('a formula list * 'a formula) list = <fun>
val mexpand :
  (fol formula list * fol formula) list ->
  fol formula list ->
  fol formula ->
  ((string, term) func * int * int -> 'a) ->
  (string, term) func * int * int -> 'a = <fun>
File "atp_interactive.ml", line 4973, characters 5-56:
Warning S: this expression should have type unit.
val puremeson : fol formula -> int = <fun>
val meson : fol formula -> int list = <fun>
val equal : (string, term) func -> fol formula -> fol formula -> bool =
  <fun>
val expand2 :
  ('a -> ('b * int * 'c -> 'd) -> 'b * int * 'c -> 'd) ->
  'a ->
  int -> 'a -> int -> int -> ('b * int * 'c -> 'd) -> 'b -> 'c -> 'd =
  <fun>
val mexpand :
  (fol formula list * fol formula) list ->
  fol formula list ->
  fol formula ->
  ((string, term) func * int * int -> 'a) ->
  (string, term) func * int * int -> 'a = <fun>
val mexpands :
  (fol formula list * fol formula) list ->
  fol formula list ->
  fol formula list ->
  ((string, term) func * int * int -> 'a) ->
  (string, term) func * int * int -> 'a = <fun>
File "atp_interactive.ml", line 5031, characters 5-56:
Warning S: this expression should have type unit.
val puremeson : fol formula -> int = <fun>
val meson : fol formula -> int list = <fun>
val rename_term : term -> term = <fun>
val rename_form : fol formula -> fol formula = <fun>
val skolems :
  fol formula list -> string list -> fol formula list * string list =
  <fun>
val skolemizes : fol formula list -> fol formula list = <fun>
val is_eq : fol formula -> bool = <fun>
val mk_eq : term -> term -> fol formula = <fun>
val dest_eq : fol formula -> term * term = <fun>
val lhs : fol formula -> term = <fun>
val rhs : fol formula -> term = <fun>
val predicates : fol formula -> (string * int) list = <fun>
val function_congruence : string * int -> fol formula list = <fun>
val predicate_congruence : string * int -> fol formula list = <fun>
val equivalence_axioms : fol formula list =
  [<<forall x. x = x>>; <<forall x y z. x = y /\ x = z ==> y = z>>]
val equalitize : fol formula -> fol formula = <fun>
val subterms : term -> term list = <fun>
val congruent : term partition -> term * term -> bool = <fun>
val emerge :
  term * term ->
  term partition * (term, term list) func ->
  term partition * (term, term list) func = <fun>
val predecessors :
  term -> (term, term list) func -> (term, term list) func = <fun>
val ccsatisfiable : fol formula list -> bool = <fun>
val ccvalid : fol formula -> bool = <fun>
val rewrite1 : fol formula list -> term -> term = <fun>
val rewrite : fol formula list -> term -> term = <fun>
val termsize : term -> int = <fun>
val lexord : ('a -> 'a -> bool) -> 'a list -> 'a list -> bool = <fun>
val lpo_gt :
  (string * int -> string * int -> bool) -> term -> term -> bool =
  <fun>
val lpo_ge :
  (string * int -> string * int -> bool) -> term -> term -> bool =
  <fun>
val weight : 'a list -> 'a * 'b -> 'a * 'b -> bool = <fun>
val renamepair : fol formula * fol formula -> fol formula * fol formula =
  <fun>
val listcases :
  ('a -> ('b -> 'a -> 'c) -> 'd list) ->
  ('b -> 'a list -> 'c) -> 'a list -> 'd list -> 'd list = <fun>
val overlaps :
  term * term -> term -> ((string, term) func -> term -> 'a) -> 'a list =
  <fun>
File "atp_interactive.ml", line 5977, characters 4-9:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Exists (_, _)|Forall (_, _)|Iff (_, _)|Imp (_, _)|Or (_, _)|And (_, _)|
Not _|True|False)
File "atp_interactive.ml", line 5977, characters 4-9:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Exists (_, _)|Forall (_, _)|Iff (_, _)|Imp (_, _)|Or (_, _)|And (_, _)|
Not _|True|False)
val crit1 : fol formula -> fol formula -> fol formula list = <fun>
val critical_pairs : fol formula -> fol formula -> fol formula list =
  <fun>
File "atp_interactive.ml", line 5997, characters 4-24:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Exists (_, _)|Forall (_, _)|Iff (_, _)|Imp (_, _)|Or (_, _)|And (_, _)|
Not _|True|False)
val normalize_and_orient :
  (term -> term -> bool) ->
  fol formula list -> fol formula -> term * term = <fun>
val status : 'a list * 'b list * 'c list -> 'a list -> unit = <fun>
val complete :
  (term -> term -> bool) ->
  fol formula list * fol formula list * fol formula list ->
  fol formula list = <fun>
File "atp_interactive.ml", line 6054, characters 2-221:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Exists (_, _)|Forall (_, _)|Iff (_, _)|Imp (_, _)|Or (_, _)|And (_, _)|
Not _|True|False)::_
val interreduce :
  fol formula list -> fol formula list -> fol formula list = <fun>
val complete_and_simplify :
  string list -> fol formula list -> fol formula list = <fun>
val modify_S : fol formula list -> fol formula list list = <fun>
val modify_T : fol formula list -> fol formula list = <fun>
val is_nonvar : term -> bool = <fun>
val find_nestnonvar : term -> term = <fun>
File "atp_interactive.ml", line 6668, characters 2-144:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Exists (_, _)|Forall (_, _)|Iff (_, _)|Imp (_, _)|Or (_, _)|And (_, _)|True|
False)
val find_nvsubterm : fol formula -> term = <fun>
val replacet : (term, term) func -> term -> term = <fun>
val replace : (term, term) func -> fol formula -> fol formula = <fun>
val emodify : string list -> fol formula list -> fol formula list =
  <fun>
val modify_E : fol formula list -> fol formula list = <fun>
val brand : fol formula list list -> fol formula list list = <fun>
File "atp_interactive.ml", line 6715, characters 5-56:
Warning S: this expression should have type unit.
val bpuremeson : fol formula -> int = <fun>
val bmeson : fol formula -> int list = <fun>
val overlapl :
  term * term ->
  fol formula -> ((string, term) func -> fol formula -> 'a) -> 'a list =
  <fun>
val overlapc :
  term * term ->
  fol formula list ->
  ((string, term) func -> fol formula list -> 'a) -> 'a list -> 'a list =
  <fun>
val paramodulate :
  fol formula list -> fol formula list -> fol formula list list = <fun>
val para_clauses :
  fol formula list -> fol formula list -> fol formula list list = <fun>
val paraloop : fol formula list list * fol formula list list -> bool =
  <fun>
val pure_paramodulation : fol formula -> bool = <fun>
val paramodulation : fol formula -> bool list = <fun>
val aedecide : fol formula -> bool = <fun>
val separate : string -> fol formula list -> fol formula = <fun>
val pushquant : string -> fol formula -> fol formula = <fun>
val miniscope : fol formula -> fol formula = <fun>
val wang : fol formula -> bool = <fun>
val atom : string -> string -> fol formula = <fun>
val premiss_A : string * string -> fol formula = <fun>
val premiss_E : string * string -> fol formula = <fun>
val premiss_I : string * string -> fol formula = <fun>
val premiss_O : string * string -> fol formula = <fun>
File "atp_interactive.ml", line 7133, characters 2-309:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Iff (_, _)|Imp (_, _)|Or (_, _)|And (_, _)|Not _|Atom _|True|False)
val anglicize_premiss : fol formula -> string = <fun>
File "atp_interactive.ml", line 7140, characters 4-23:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Exists (_, _)|Forall (_, _)|Iff (_, _)|Or (_, _)|And (_, _)|Not _|Atom _|
True|False)
val anglicize_syllogism : fol formula -> string = <fun>
val all_possible_syllogisms : fol formula list =
  [<<(forall x. M(x) ==> P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. M(x) ==> P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. P(x) ==> M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. M(x) ==> ~P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(forall x. P(x) ==> ~M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. M(x) /\ P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x) /\ M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. M(x) /\ ~P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x) /\ ~M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>]
val all_possible_syllogisms' : fol formula list =
  [<<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. M(x) ==> ~P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (forall x. P(x) ==> ~M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. M(x) /\ ~P(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (forall x. S(x) ==> M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (forall x. M(x) ==> S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (forall x. S(x) ==> ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (forall x. M(x) ==> ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (exists x. S(x) /\ M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (exists x. M(x) /\ S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (exists x. S(x) /\ ~M(x)) ==>
     (exists x. S(x) /\ ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (forall x. S(x) ==> ~P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ P(x))>>;
   <<(exists x. P(x)) /\ (exists x. M(x)) /\ (exists x. S(x)) ==>
     (exists x. P(x) /\ ~M(x)) /\ (exists x. M(x) /\ ~S(x)) ==>
     (exists x. S(x) /\ ~P(x))>>]
val alltuples : int -> 'a list -> 'a list list = <fun>
val allmappings : 'a list -> 'b list -> ('a -> 'b) list = <fun>
val alldepmappings :
  ('a * 'b) list -> ('b -> 'c list) -> ('a -> 'c) list = <fun>
val allfunctions : 'a list -> int -> ('a list -> 'a) list = <fun>
val allpredicates : 'a list -> int -> ('a list -> bool) list = <fun>
val decide_finite : int -> fol formula -> bool = <fun>
val limmeson : int -> fol formula -> (string, term) func * int * int =
  <fun>
val limited_meson :
  int -> fol formula -> ((string, term) func * int * int) list = <fun>
File "atp_interactive.ml", line 7218, characters 8-26:
Warning S: this expression should have type unit.
val decide_fmp : fol formula -> bool = <fun>
val decide_monadic : fol formula -> bool = <fun>
val qelim :
  (fol formula -> fol formula) -> string -> fol formula -> fol formula =
  <fun>
val lift_qelim :
  (string list -> fol formula -> fol formula) ->
  (fol formula -> fol formula) ->
  (string list -> fol formula -> fol formula) ->
  fol formula -> fol formula = <fun>
val cnnf : (fol formula -> fol formula) -> fol formula -> fol formula =
  <fun>
val lfn_dlo : fol formula -> fol formula = <fun>
File "atp_interactive.ml", line 7377, characters 23-60:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Exists (_, _)|Forall (_, _)|Iff (_, _)|Imp (_, _)|Or (_, _)|And (_, _)|
Not _|True|False)
File "atp_interactive.ml", line 7378, characters 24-53:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Exists (_, _)|Forall (_, _)|Iff (_, _)|Imp (_, _)|Or (_, _)|And (_, _)|
Not _|True|False)
File "atp_interactive.ml", line 7379, characters 24-53:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Exists (_, _)|Forall (_, _)|Iff (_, _)|Imp (_, _)|Or (_, _)|And (_, _)|
Not _|True|False)
File "atp_interactive.ml", line 7367, characters 2-701:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Forall (_, _)|Iff (_, _)|Imp (_, _)|Or (_, _)|And (_, _)|Not _|Atom _|True|
False)
val dlobasic : fol formula -> fol formula = <fun>
val afn_dlo : 'a -> fol formula -> fol formula = <fun>
val quelim_dlo : fol formula -> fol formula = <fun>
val zero : term = <<|0|>>
val mk_numeral : num -> term = <fun>
val dest_numeral : term -> num = <fun>
val is_numeral : term -> bool = <fun>
val numeral1 : (num -> num) -> term -> term = <fun>
val numeral2 : (num -> num -> num) -> term -> term -> term = <fun>
val linear_cmul : num -> term -> term = <fun>
val linear_add : string list -> term -> term -> term = <fun>
val linear_neg : term -> term = <fun>
val linear_sub : string list -> term -> term -> term = <fun>
val linear_mul : term -> term -> term = <fun>
val lint : string list -> term -> term = <fun>
val mkatom : string list -> string -> term -> fol formula = <fun>
val linform : string list -> fol formula -> fol formula = <fun>
val posineq : fol formula -> fol formula = <fun>
val formlcm : term -> fol formula -> num = <fun>
val adjustcoeff : term -> num -> fol formula -> fol formula = <fun>
val unitycoeff : term -> fol formula -> fol formula = <fun>
val minusinf : term -> fol formula -> fol formula = <fun>
val divlcm : term -> fol formula -> num = <fun>
val bset : term -> fol formula -> term list = <fun>
val linrep : string list -> term -> term -> fol formula -> fol formula =
  <fun>
val cooper : string list -> fol formula -> fol formula = <fun>
val operations : (string * (num -> num -> bool)) list =
  [("=", <fun>); ("<", <fun>); (">", <fun>); ("<=", <fun>);
   (">=", <fun>); ("divides", <fun>)]
File "atp_interactive.ml", line 7705, characters 3-167:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
R (_, [])
val evalc : fol formula -> fol formula = <fun>
val integer_qelim : fol formula -> fol formula = <fun>
val relativize : (string -> 'a formula) -> 'a formula -> 'a formula =
  <fun>
val natural_qelim : fol formula -> fol formula = <fun>
File "atp_interactive.ml", line 8023, characters 11-106:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Var _
val poly_add : string list -> term -> term -> term = <fun>
val poly_ladd : string list -> term -> term -> term = <fun>
val poly_neg : term -> term = <fun>
val poly_sub : string list -> term -> term -> term = <fun>
File "atp_interactive.ml", line 8043, characters 11-199:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Var _
val poly_mul : string list -> term -> term -> term = <fun>
val poly_lmul : string list -> term -> term -> term = <fun>
val poly_pow : string list -> term -> int -> term = <fun>
val poly_div : string list -> term -> term -> term = <fun>
val poly_var : string -> term = <fun>
val polynate : string list -> term -> term = <fun>
val polyatom : string list -> fol formula -> fol formula = <fun>
val coefficients : string list -> term -> term list = <fun>
val degree : string list -> term -> int = <fun>
val is_constant : string list -> term -> bool = <fun>
val head : string list -> term -> term = <fun>
val behead : string list -> term -> term = <fun>
val poly_cmul : num -> term -> term = <fun>
File "atp_interactive.ml", line 8124, characters 2-96:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Var _
val headconst : term -> num = <fun>
val monic : term -> term * bool = <fun>
val pdivide : string list -> term -> term -> int * term = <fun>
type sign = Zero | Nonzero | Positive | Negative
val swap : bool -> sign -> sign = <fun>
val findsign : (term * sign) list -> term -> sign = <fun>
val assertsign :
  (term * sign) list -> term * sign -> (term * sign) list = <fun>
val split_zero :
  (term * sign) list ->
  term ->
  ((term * sign) list -> fol formula) ->
  ((term * sign) list -> fol formula) -> fol formula = <fun>
val poly_nonzero :
  string list -> (term * sign) list -> term -> fol formula = <fun>
val poly_nondiv :
  string list -> (term * sign) list -> term -> term -> fol formula =
  <fun>
val cqelim :
  string list ->
  term list * term list -> (term * sign) list -> fol formula = <fun>
val init_sgns : (term * sign) list =
  [(<<|1|>>, Positive); (<<|0|>>, Zero)]
File "atp_interactive.ml", line 8244, characters 4-23:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Forall (_, _)|Iff (_, _)|Imp (_, _)|Or (_, _)|And (_, _)|Not _|Atom _|True|
False)
val basic_complex_qelim : string list -> fol formula -> fol formula =
  <fun>
val complex_qelim : fol formula -> fol formula = <fun>
val poly_diffn : term -> int -> term -> term = <fun>
val poly_diff : string list -> term -> term = <fun>
val rel_signs : (string * sign list) list =
  [("=", [Zero]); ("<=", [Zero; Negative]); (">=", [Zero; Positive]);
   ("<", [Negative]); (">", [Positive])]
File "atp_interactive.ml", line 9032, characters 11-69:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
R (_, [])
val testform : (term * sign) list -> fol formula -> bool = <fun>
val inferpsign : sign list * sign list -> sign list = <fun>
val condense : sign list list -> sign list list = <fun>
val inferisign : sign list list -> sign list list = <fun>
val dedmatrix : (sign list list -> 'a) -> sign list list -> 'a = <fun>
val pdivide_pos :
  string list -> (term * sign) list -> term -> term -> term = <fun>
val split_sign :
  (term * sign) list ->
  term -> ((term * sign) list -> fol formula) -> fol formula = <fun>
val split_trichotomy :
  (term * sign) list ->
  term ->
  ((term * sign) list -> fol formula) ->
  ((term * sign) list -> fol formula) -> fol formula = <fun>
val casesplit :
  string list ->
  term list ->
  term list ->
  (sign list list -> fol formula) -> (term * sign) list -> fol formula =
  <fun>
val delconst :
  string list ->
  term list ->
  term ->
  term list ->
  (sign list list -> fol formula) -> (term * sign) list -> fol formula =
  <fun>
val matrix :
  string list ->
  term list ->
  (sign list list -> fol formula) -> (term * sign) list -> fol formula =
  <fun>
File "atp_interactive.ml", line 9137, characters 4-20:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Forall (_, _)|Iff (_, _)|Imp (_, _)|Or (_, _)|And (_, _)|Not _|Atom _|True|
False)
val basic_real_qelim : string list -> fol formula -> fol formula =
  <fun>
val real_qelim : fol formula -> fol formula = <fun>
File "atp_interactive.ml", line 9185, characters 2-243:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Fn ("", _)
val grpterm : term -> term = <fun>
File "atp_interactive.ml", line 9192, characters 4-11:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Exists (_, _)|Forall (_, _)|Iff (_, _)|Imp (_, _)|Or (_, _)|And (_, _)|
Not _|True|False)
val grpform : fol formula -> fol formula = <fun>
val real_qelim' : fol formula -> fol formula = <fun>
- : fol formula = <<true>>
val mmul : num * int list -> num * int list -> num * int list = <fun>
val mdiv : num * int list -> num * int list -> num * int list = <fun>
val mlcm : 'a * 'b list -> 'c * 'b list -> num * 'b list = <fun>
val morder_lt : int list -> int list -> bool = <fun>
val mpoly_mmul :
  num * int list -> (num * int list) list -> (num * int list) list =
  <fun>
val mpoly_neg : (num * '_a) list -> (num * '_a) list = <fun>
val mpoly_const : 'a list -> num -> (num * int list) list = <fun>
val mpoly_var : 'a list -> 'a -> (num * int list) list = <fun>
val mpoly_add :
  (num * int list) list ->
  (num * int list) list -> (num * int list) list = <fun>
val mpoly_sub :
  (num * int list) list ->
  (num * int list) list -> (num * int list) list = <fun>
val mpoly_mul :
  (num * int list) list ->
  (num * int list) list -> (num * int list) list = <fun>
val mpoly_pow :
  'a list -> (num * int list) list -> int -> (num * int list) list =
  <fun>
val mpoly_inv : (num * int list) list -> (num * int list) list = <fun>
val mpoly_div :
  (num * int list) list ->
  (num * int list) list -> (num * int list) list = <fun>
val mpolynate : string list -> term -> (num * int list) list = <fun>
val mpolyatom : string list -> fol formula -> (num * int list) list =
  <fun>
val reduce1 :
  num * int list -> (num * int list) list -> (num * int list) list =
  <fun>
val reduceb :
  num * int list -> (num * int list) list list -> (num * int list) list =
  <fun>
val reduce :
  (num * int list) list list ->
  (num * int list) list -> (num * int list) list = <fun>
val spoly :
  (num * int list) list ->
  (num * int list) list -> (num * int list) list = <fun>
val grobner :
  (num * int list) list list ->
  ((num * int list) list * (num * int list) list) list ->
  (num * int list) list list = <fun>
val groebner : (num * int list) list list -> (num * int list) list list =
  <fun>
val rabinowitsch :
  'a list -> 'a -> (num * int list) list -> (num * int list) list =
  <fun>
val grobner_trivial : fol formula list -> bool = <fun>
val grobner_decide : fol formula -> bool = <fun>
val coordinations : (string * fol formula) list =
  [("collinear",
    <<(1_x - 2_x) * (2_y - 3_y) = (1_y - 2_y) * (2_x - 3_x)>>);
   ("parallel",
    <<(1_x - 2_x) * (3_y - 4_y) = (1_y - 2_y) * (3_x - 4_x)>>);
   ("perpendicular",
    <<(1_x - 2_x) * (3_x - 4_x) + (1_y - 2_y) * (3_y - 4_y) = 0>>);
   ("lengths_eq",
    <<(1_x - 2_x)^2 + (1_y - 2_y)^2 = (3_x - 4_x)^2 + (3_y - 4_y)^2>>);
   ("is_midpoint", <<2 * 1_x = 2_x + 3_x /\ 2 * 1_y = 2_y + 3_y>>);
   ("is_intersection",
    <<(1_x - 2_x) * (2_y - 3_y) = (1_y - 2_y) * (2_x - 3_x) /\
      (1_x - 4_x) * (4_y - 5_y) = (1_y - 4_y) * (4_x - 5_x)>>);
   ("=", <<1_x = 2_x /\ 1_y = 2_y>>)]
File "atp_interactive.ml", line 9729, characters 11-49:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Fn (_, _)
val coordinate : fol formula -> fol formula = <fun>
val invariant : term * term -> string * fol formula -> fol formula =
  <fun>
val invariant_under_translation : string * fol formula -> fol formula =
  <fun>
val invariant_under_rotation : string * fol formula -> fol formula =
  <fun>
File "atp_interactive.ml", line 9781, characters 6-15:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val originate : fol formula -> fol formula = <fun>
val invariant_under_scaling : string * fol formula -> fol formula =
  <fun>
val invariant_under_shearing : string * fol formula -> fol formula =
  <fun>
File "atp_interactive.ml", line 9830, characters 2-522:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Var _::_
val pprove :
  string list ->
  term list -> term -> fol formula list -> fol formula list = <fun>
val triangulate : string list -> term list -> term list -> term list =
  <fun>
val wu : fol formula -> string list -> string list -> fol formula list =
  <fun>
val pinterpolate : 'a formula -> 'a formula -> 'a formula = <fun>
File "atp_interactive.ml", line 9984, characters 26-47:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Exists (_, _)|Forall (_, _)|Iff (_, _)|Imp (_, _)|Or (_, _)|Not _|Atom _|
True|False)
val urinterpolate : fol formula -> fol formula -> fol formula = <fun>
val toptermt : (string * int) list -> term -> term list = <fun>
val topterms : (string * int) list -> fol formula -> term list = <fun>
File "atp_interactive.ml", line 10023, characters 4-287:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Var _::_
val uinterpolate : fol formula -> fol formula -> fol formula = <fun>
File "atp_interactive.ml", line 10055, characters 6-18:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
((Exists (_, _)|Forall (_, _)|Iff (_, _)|Imp (_, _)|Or (_, _)|Not _|Atom _|
 True|False),
_)
val cinterpolate : fol formula -> fol formula -> fol formula = <fun>
val interpolate : fol formula -> fol formula -> fol formula = <fun>
val einterpolate : fol formula -> fol formula -> fol formula = <fun>
val real_lang :
  (string * int -> bool) * (string * int -> bool) *
  (fol formula -> bool) = (<fun>, <fun>, <fun>)
val int_lang :
  (string * int -> bool) * (string * int -> bool) *
  (fol formula -> bool) = (<fun>, <fun>, <fun>)
val add_default :
  (('a -> bool) * (string * int -> bool) * (fol formula -> bool)) list ->
  (('a -> bool) * (string * int -> bool) * (fol formula -> bool)) list =
  <fun>
File "atp_interactive.ml", line 10222, characters 2-217:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Exists (_, _)|Forall (_, _)|Iff (_, _)|Imp (_, _)|Or (_, _)|And (_, _)|
Not _|True|False)
val chooselang :
  ((string * int -> bool) * (string * int -> bool) * 'a) list ->
  fol formula -> (string * int -> bool) * (string * int -> bool) * 'a =
  <fun>
val listify :
  ('a -> ('b -> 'c) -> 'c) -> 'a list -> ('b list -> 'c) -> 'c = <fun>
val homot :
  (string * int -> bool) * 'a * 'b ->
  term ->
  (term -> num -> fol formula list -> 'c) ->
  num -> fol formula list -> 'c = <fun>
val homol :
  ((string * int -> bool) * (string * int -> bool) * 'a) list ->
  fol formula ->
  (fol formula -> num -> fol formula list -> 'b) ->
  num -> fol formula list -> 'b = <fun>
val homo :
  ((string * int -> bool) * (string * int -> bool) * 'a) list ->
  fol formula list ->
  (fol formula list -> num -> fol formula list -> 'b) ->
  num -> fol formula list -> 'b = <fun>
val homogenize :
  ((string * int -> bool) * (string * int -> bool) * 'a) list ->
  fol formula list -> fol formula list = <fun>
val belongs :
  (string * int -> bool) * (string * int -> bool) * 'a ->
  fol formula -> bool = <fun>
val langpartition :
  ((string * int -> bool) * (string * int -> bool) * 'a) list ->
  fol formula list -> fol formula list list = <fun>
val arreq : string list -> fol formula list = <fun>
val arrangement : string list list -> fol formula list = <fun>
val dest_def : fol formula -> string * term = <fun>
val redeqs : fol formula list -> fol formula list = <fun>
val trydps :
  (('a * 'b * (fol formula -> bool)) * fol formula list) list ->
  fol formula list -> bool = <fun>
val allpartitions : 'a list -> 'a list list list = <fun>
val nelop_refute :
  string list ->
  (('a * 'b * (fol formula -> bool)) * fol formula list) list -> bool =
  <fun>
val nelop1 :
  ((string * int -> bool) * (string * int -> bool) *
   (fol formula -> bool))
  list -> fol formula list -> bool = <fun>
val nelop :
  ((string * int -> bool) * (string * int -> bool) *
   (fol formula -> bool))
  list -> fol formula -> bool = <fun>
val findasubset : ('a list -> 'b) -> int -> 'a list -> 'b = <fun>
val findsubset : ('a list -> bool) -> 'a list -> 'a list = <fun>
val nelop_refute :
  fol formula list ->
  (('a * 'b * (fol formula -> bool)) * fol formula list) list -> bool =
  <fun>
val nelop1 :
  ((string * int -> bool) * (string * int -> bool) *
   (fol formula -> bool))
  list -> fol formula list -> bool = <fun>
val nelop :
  ((string * int -> bool) * (string * int -> bool) *
   (fol formula -> bool))
  list -> fol formula -> bool = <fun>
module type Proofsystem =
  sig
    type thm
    val modusponens : thm -> thm -> thm
    val gen : string -> thm -> thm
    val axiom_addimp : fol formula -> fol formula -> thm
    val axiom_distribimp :
      fol formula -> fol formula -> fol formula -> thm
    val axiom_doubleneg : fol formula -> thm
    val axiom_allimp : string -> fol formula -> fol formula -> thm
    val axiom_impall : string -> fol formula -> thm
    val axiom_existseq : string -> term -> thm
    val axiom_eqrefl : term -> thm
    val axiom_funcong : string -> term list -> term list -> thm
    val axiom_predcong : string -> term list -> term list -> thm
    val axiom_iffimp1 : fol formula -> fol formula -> thm
    val axiom_iffimp2 : fol formula -> fol formula -> thm
    val axiom_impiff : fol formula -> fol formula -> thm
    val axiom_true : thm
    val axiom_not : fol formula -> thm
    val axiom_and : fol formula -> fol formula -> thm
    val axiom_or : fol formula -> fol formula -> thm
    val axiom_exists : string -> fol formula -> thm
    val concl : thm -> fol formula
  end
val occurs_in : term -> term -> bool = <fun>
val free_in : term -> fol formula -> bool = <fun>
module Proven : Proofsystem
type thm = Proven.thm
val modusponens : thm -> thm -> thm = <fun>
val gen : string -> thm -> thm = <fun>
val axiom_addimp : fol formula -> fol formula -> thm = <fun>
val axiom_distribimp : fol formula -> fol formula -> fol formula -> thm =
  <fun>
val axiom_doubleneg : fol formula -> thm = <fun>
val axiom_allimp : string -> fol formula -> fol formula -> thm = <fun>
val axiom_impall : string -> fol formula -> thm = <fun>
val axiom_existseq : string -> term -> thm = <fun>
val axiom_eqrefl : term -> thm = <fun>
val axiom_funcong : string -> term list -> term list -> thm = <fun>
val axiom_predcong : string -> term list -> term list -> thm = <fun>
val axiom_iffimp1 : fol formula -> fol formula -> thm = <fun>
val axiom_iffimp2 : fol formula -> fol formula -> thm = <fun>
val axiom_impiff : fol formula -> fol formula -> thm = <fun>
val axiom_true : thm = <abstr>
val axiom_not : fol formula -> thm = <fun>
val axiom_and : fol formula -> fol formula -> thm = <fun>
val axiom_or : fol formula -> fol formula -> thm = <fun>
val axiom_exists : string -> fol formula -> thm = <fun>
val concl : thm -> fol formula = <fun>
val print_thm : thm -> unit = <fun>
val imp_refl : fol formula -> thm = <fun>
val imp_unduplicate : thm -> thm = <fun>
val negatef : 'a formula -> 'a formula = <fun>
val negativef : 'a formula -> bool = <fun>
val add_assum : fol formula -> thm -> thm = <fun>
val imp_add_assum : fol formula -> thm -> thm = <fun>
val imp_trans : thm -> thm -> thm = <fun>
val imp_insert : fol formula -> thm -> thm = <fun>
val imp_swap : thm -> thm = <fun>
val imp_trans_th : fol formula -> fol formula -> fol formula -> thm =
  <fun>
val imp_add_concl : fol formula -> thm -> thm = <fun>
val imp_swap_th : fol formula -> fol formula -> fol formula -> thm =
  <fun>
val imp_swap2 : thm -> thm = <fun>
val right_mp : thm -> thm -> thm = <fun>
val iff_imp1 : thm -> thm = <fun>
val iff_imp2 : thm -> thm = <fun>
val imp_antisym : thm -> thm -> thm = <fun>
val right_doubleneg : thm -> thm = <fun>
val ex_falso : fol formula -> thm = <fun>
File "atp_interactive.ml", line 10858, characters 6-21:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Exists (_, _)|Forall (_, _)|Iff (_, _)|Or (_, _)|And (_, _)|Not _|Atom _|
True|False)
File "atp_interactive.ml", line 10858, characters 38-47:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Exists (_, _)|Forall (_, _)|Iff (_, _)|Or (_, _)|And (_, _)|Not _|Atom _|
True|False)
val imp_trans2 : thm -> thm -> thm = <fun>
val imp_trans_chain : thm list -> thm -> thm = <fun>
val imp_truefalse : fol formula -> fol formula -> thm = <fun>
val imp_mono_th :
  fol formula -> fol formula -> fol formula -> fol formula -> thm =
  <fun>
val truth : thm = |- true
val contrapos : thm -> thm = <fun>
val and_left : fol formula -> fol formula -> thm = <fun>
val and_right : fol formula -> fol formula -> thm = <fun>
val conjths : fol formula -> thm list = <fun>
val and_pair : fol formula -> fol formula -> thm = <fun>
val shunt : thm -> thm = <fun>
val unshunt : thm -> thm = <fun>
val iff_def : fol formula -> fol formula -> thm = <fun>
val iff_def : fol formula -> fol formula -> thm = <fun>
val expand_connective : fol formula -> thm = <fun>
val eliminate_connective : fol formula -> thm = <fun>
val imp_false_conseqs : fol formula -> fol formula -> thm list = <fun>
val imp_false_rule : thm -> thm = <fun>
val imp_true_rule : thm -> thm -> thm = <fun>
val imp_contr : fol formula -> fol formula -> thm = <fun>
val imp_front_th : int -> fol formula -> thm = <fun>
val imp_front : int -> thm -> thm = <fun>
val lcfptab : fol formula list -> fol formula list -> thm = <fun>
val lcftaut : fol formula -> thm = <fun>
val eq_sym : term -> term -> thm = <fun>
val eq_trans : term -> term -> term -> thm = <fun>
val icongruence : term -> term -> term -> term -> thm = <fun>
val gen_right_th : string -> fol formula -> fol formula -> thm = <fun>
val genimp : string -> thm -> thm = <fun>
val gen_right : string -> thm -> thm = <fun>
val exists_left_th : string -> fol formula -> fol formula -> thm =
  <fun>
val exists_left : string -> thm -> thm = <fun>
val subspec : thm -> thm = <fun>
val subalpha : thm -> thm = <fun>
val isubst : term -> term -> fol formula -> fol formula -> thm = <fun>
val alpha : string -> fol formula -> thm = <fun>
val ispec : term -> fol formula -> thm = <fun>
val spec : term -> thm -> thm = <fun>
val unify_complementsf :
  (string, term) func ->
  fol formula * fol formula -> (string, term) func = <fun>
File "atp_interactive.ml", line 11376, characters 2-402:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Exists (_, _)|Forall (_, _)|Iff (_, _)|Or (_, _)|And (_, _)|Not _|Atom _|
True|False)
val use_laterimp : fol formula -> fol formula -> thm = <fun>
val imp_false_rule' : ('a -> thm) -> 'a -> thm = <fun>
val imp_true_rule' : ('a -> thm) -> ('a -> thm) -> 'a -> thm = <fun>
val imp_front' : int -> ('a -> thm) -> 'a -> thm = <fun>
val add_assum' :
  fol formula ->
  ((term -> term) * 'a -> thm) -> (term -> term) * 'a -> thm = <fun>
val eliminate_connective' :
  fol formula ->
  ((term -> term) * 'a -> thm) -> (term -> term) * 'a -> thm = <fun>
val spec' :
  term ->
  fol formula ->
  int -> ((term -> term) * 'a -> thm) -> (term -> term) * 'a -> thm =
  <fun>
val ex_falso' : fol formula list -> (term -> term) * fol formula -> thm =
  <fun>
File "atp_interactive.ml", line 11409, characters 6-15:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(_, [])
File "atp_interactive.ml", line 11408, characters 4-13:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
([], _)
val complits' :
  fol formula list * fol formula list ->
  int -> (term -> term) * fol formula -> thm = <fun>
val deskol' :
  fol formula ->
  ((term -> term) * 'a -> thm) -> (term -> term) * 'a -> thm = <fun>
val lcftab :
  (fol formula -> term) ->
  fol formula list * fol formula list * int ->
  (((term -> term) * fol formula -> thm) ->
   (string, term) func * (fol formula * term) list * int -> 'a) ->
  (string, term) func * (fol formula * term) list * int -> 'a = <fun>
val quantforms : bool -> 'a formula -> 'a formula list = <fun>
File "atp_interactive.ml", line 11483, characters 6-12:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Exists (_, _)|Iff (_, _)|Imp (_, _)|Or (_, _)|And (_, _)|Not _|Atom _|True|
False)
val skolemfuns : fol formula -> (fol formula * term) list = <fun>
val form_match :
  fol formula * fol formula ->
  (string, term) func -> (string, term) func = <fun>
val lcfrefute :
  fol formula ->
  int ->
  (((term -> term) * fol formula -> thm) ->
   (string, term) func * (fol formula * term) list * int -> 'a) ->
  'a = <fun>
File "atp_interactive.ml", line 11520, characters 4-11:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
((Exists (_, _)|Iff (_, _)|Imp (_, _)|Or (_, _)|And (_, _)|Not _|Atom _|True|
 False),
_)
val mk_skol : fol formula * term -> fol formula -> fol formula = <fun>
val simpcont :
  ((term -> term) * fol formula -> 'a) ->
  (string, term) func * (fol formula * term) list * 'b -> 'a = <fun>
- : thm = |- p(1) /\ ~q(1) /\ (forall x. p(x) ==> q(x)) ==> false
- : thm =
|-
(exists x. ~p(x)) /\ (forall x. p(x)) ==>
(~(~p(f_1)) ==> (forall x. ~(~p(x)))) ==> false
File "atp_interactive.ml", line 11540, characters 12-21:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val elim_skolemvar : thm -> thm = <fun>
val deskolcont :
  ((term -> term) * fol formula -> thm) ->
  (string, term) func * (fol formula * term) list * 'a -> thm = <fun>
val lcffol : fol formula -> thm = <fun>
type goals =
    Goals of ((string * fol formula) list * fol formula) list *
      (thm list -> thm)
val print_goal : goals -> unit = <fun>
File "atp_interactive.ml", line 11995, characters 15-52:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val set_goal : fol formula -> goals = <fun>
val extract_thm : goals -> thm = <fun>
val tac_proof : goals -> (goals -> goals) list -> thm = <fun>
val prove : fol formula -> (goals -> goals) list -> thm = <fun>
File "atp_interactive.ml", line 12011, characters 6-10:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
File "atp_interactive.ml", line 12010, characters 4-18:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Goals ([], _)
val conj_intro_tac : goals -> goals = <fun>
File "atp_interactive.ml", line 12019, characters 4-11:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val jmodify : ('a list -> 'b) -> ('a -> 'a) -> 'a list -> 'b = <fun>
val gen_right_alpha : string -> string -> thm -> thm = <fun>
File "atp_interactive.ml", line 12033, characters 4-20:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Goals ([], _)
val forall_intro_tac : string -> goals -> goals = <fun>
File "atp_interactive.ml", line 12045, characters 6-17:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Exists (_, _)|Forall (_, _)|Iff (_, _)|Imp (_, _)|Or (_, _)|And (_, _)|
Atom _|True|False)
val right_exists : string -> term -> fol formula -> thm = <fun>
File "atp_interactive.ml", line 12054, characters 4-20:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Goals ([], _)
val exists_intro_tac : term -> goals -> goals = <fun>
File "atp_interactive.ml", line 12062, characters 4-17:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Goals ([], _)
val imp_intro_tac : string -> goals -> goals = <fun>
File "atp_interactive.ml", line 12070, characters 4-14:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Goals ([], _)
val assumptate : goals -> thm -> thm = <fun>
val firstassum : ('a * fol formula) list -> thm = <fun>
val using : thm list -> 'a -> goals -> thm list = <fun>
val assumps : ('a * fol formula) list -> ('a * thm) list = <fun>
File "atp_interactive.ml", line 12107, characters 4-6:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Goals ([], _)
val by : string list -> 'a -> goals -> thm list = <fun>
val justify :
  ('a -> fol formula -> goals -> thm list) ->
  'a -> fol formula -> goals -> thm = <fun>
File "atp_interactive.ml", line 12126, characters 28-42:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
File "atp_interactive.ml", line 12125, characters 4-9:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Goals ([], _)
val proof : (goals -> goals) list -> fol formula -> goals -> thm list =
  <fun>
val at : 'a -> 'b -> 'c -> 'd list = <fun>
val once : 'a list = []
File "atp_interactive.ml", line 12138, characters 4-12:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Goals ([], _)
val auto_tac :
  ('a -> fol formula -> goals -> thm list) -> 'a -> goals -> goals =
  <fun>
File "atp_interactive.ml", line 12146, characters 4-13:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Goals ([], _)
val lemma_tac :
  string ->
  fol formula ->
  ('a -> fol formula -> goals -> thm list) -> 'a -> goals -> goals =
  <fun>
File "atp_interactive.ml", line 12156, characters 6-17:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Forall (_, _)|Iff (_, _)|Imp (_, _)|Or (_, _)|And (_, _)|Not _|Atom _|True|
False)
File "atp_interactive.ml", line 12155, characters 4-19:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Goals ([], _)
val exists_elim_tac :
  string ->
  fol formula ->
  ('a -> fol formula -> goals -> thm list) -> 'a -> goals -> goals =
  <fun>
val ante_disj : thm -> thm -> thm = <fun>
File "atp_interactive.ml", line 12181, characters 38-45:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Exists (_, _)|Forall (_, _)|Iff (_, _)|Imp (_, _)|And (_, _)|Not _|Atom _|
True|False)
File "atp_interactive.ml", line 12182, characters 6-10:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
File "atp_interactive.ml", line 12180, characters 4-17:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Goals ([], _)
val disj_elim_tac :
  string ->
  fol formula ->
  ('a -> fol formula -> goals -> thm list) -> 'a -> goals -> goals =
  <fun>
val multishunt : int -> thm -> thm = <fun>
File "atp_interactive.ml", line 12230, characters 4-10:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Goals ([], _)
val assume : (string * fol formula) list -> goals -> goals = <fun>
val note :
  string * fol formula ->
  ('a -> fol formula -> goals -> thm list) -> 'a -> goals -> goals =
  <fun>
val have :
  fol formula ->
  ('a -> fol formula -> goals -> thm list) -> 'a -> goals -> goals =
  <fun>
File "atp_interactive.ml", line 12241, characters 22-106:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Goals ([], _)
val so :
  ('a -> ('b -> 'c -> goals -> thm list) -> 'd) ->
  'a -> ('b -> 'c -> goals -> thm list) -> 'd = <fun>
val fix : string -> goals -> goals = <fun>
val consider :
  string * fol formula ->
  ('a -> fol formula -> goals -> thm list) -> 'a -> goals -> goals =
  <fun>
val take : term -> goals -> goals = <fun>
val cases :
  fol formula ->
  ('_a -> fol formula -> goals -> thm list) -> '_a -> goals -> goals =
  <fun>
File "atp_interactive.ml", line 12256, characters 4-12:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Goals ([], _)
val conclude :
  fol formula ->
  ('a -> fol formula -> goals -> thm list) -> 'a -> goals -> goals =
  <fun>
File "atp_interactive.ml", line 12268, characters 4-7:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Goals ([], _)
val our :
  'a ->
  ('b -> fol formula -> goals -> thm list) -> 'b -> goals -> goals =
  <fun>
val thesis : string = ""
File "atp_interactive.ml", line 12276, characters 4-7:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Goals ([], _)
val qed : goals -> goals = <fun>
val numeral : num -> term = <fun>
val number : string -> num = <fun>
val pair : num -> num -> num = <fun>
val gterm : term -> num = <fun>
val gform : fol formula -> num = <fun>
val gnumeral : num -> num = <fun>
val diag : string -> string = <fun>
val phi : string = "P(diag(`P(diag(x))'))"
val qdiag : string -> string = <fun>
val phi : string = "let `x' be `P(qdiag(x))' in P(qdiag(x))"
(fun s -> Printf.printf "%s\n%S\n" s s)
"(fun s -> Printf.printf \"%s\\n%S\\n\" s s)"
- : unit = ()
val diag : string -> fol formula -> fol formula = <fun>
val qdiag : string -> fol formula -> fol formula = <fun>
val dtermval : (string, num) func -> term -> num = <fun>
val dholds : (string, num) func -> fol formula -> bool = <fun>
val dhquant :
  ((num -> bool) -> num list -> bool) ->
  (string, num) func ->
  string -> string -> string -> term -> fol formula -> bool = <fun>
type formulaclass = Sigma | Pi | Delta
val opp : formulaclass -> formulaclass = <fun>
val classify : formulaclass -> int -> fol formula -> bool = <fun>
File "atp_interactive.ml", line 12746, characters 2-936:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Exists (_, _)|Forall (_, _))
(However, some guarded clause may match this value.)
val veref :
  (bool -> bool) -> num -> (string, num) func -> fol formula -> bool =
  <fun>
val verefboundquant :
  num ->
  (string, num) func ->
  string ->
  string -> string -> term -> (bool -> bool) -> fol formula -> bool =
  <fun>
val sholds : num -> (string, num) func -> fol formula -> bool = <fun>
val sigma_bound : fol formula -> num = <fun>
type symbol = Blank | One
type direction = Left | Right | Stay
type tape = Tape of int * (int, symbol) func
val look : tape -> symbol = <fun>
val write : symbol -> tape -> tape = <fun>
val move : direction -> tape -> tape = <fun>
type config = Config of int * tape
val run :
  (int * symbol, symbol * direction * int) func -> config -> config =
  <fun>
val input_tape : int list -> tape = <fun>
val output_tape : tape -> int = <fun>
val exec :
  (int * symbol, symbol * direction * int) func -> int list -> int =
  <fun>
val robinson : fol formula =
  <<(forall m n. S(m) = S(n) ==> m = n) /\
    (forall n. ~n = 0 <=> (exists m. n = S(m))) /\
    (forall n. 0 + n = n) /\
    (forall m n. S(m) + n = S(m + n)) /\
    (forall n. 0 * n = 0) /\
    (forall m n. S(m) * n = n + m * n) /\
    (forall m n. m <= n <=> (exists d. m + d = n)) /\
    (forall m n. m < n <=> S(m) <= n)>>
File "atp_interactive.ml", line 12910, characters 4-77:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val suc_inj : thm =
  |-
  (forall m n. S(m) = S(n) ==> m = n) /\
  (forall n. ~n = 0 <=> (exists m. n = S(m))) /\
  (forall n. 0 + n = n) /\
  (forall m n. S(m) + n = S(m + n)) /\
  (forall n. 0 * n = 0) /\
  (forall m n. S(m) * n = n + m * n) /\
  (forall m n. m <= n <=> (exists d. m + d = n)) /\
  (forall m n. m < n <=> S(m) <= n) ==>
  (forall m n. S(m) = S(n) ==> m = n)
val num_cases : thm =
  |-
  (forall m n. S(m) = S(n) ==> m = n) /\
  (forall n. ~n = 0 <=> (exists m. n = S(m))) /\
  (forall n. 0 + n = n) /\
  (forall m n. S(m) + n = S(m + n)) /\
  (forall n. 0 * n = 0) /\
  (forall m n. S(m) * n = n + m * n) /\
  (forall m n. m <= n <=> (exists d. m + d = n)) /\
  (forall m n. m < n <=> S(m) <= n) ==>
  (forall n. ~n = 0 <=> (exists m. n = S(m)))
val add_0 : thm =
  |-
  (forall m n. S(m) = S(n) ==> m = n) /\
  (forall n. ~n = 0 <=> (exists m. n = S(m))) /\
  (forall n. 0 + n = n) /\
  (forall m n. S(m) + n = S(m + n)) /\
  (forall n. 0 * n = 0) /\
  (forall m n. S(m) * n = n + m * n) /\
  (forall m n. m <= n <=> (exists d. m + d = n)) /\
  (forall m n. m < n <=> S(m) <= n) ==> (forall n. 0 + n = n)
val add_suc : thm =
  |-
  (forall m n. S(m) = S(n) ==> m = n) /\
  (forall n. ~n = 0 <=> (exists m. n = S(m))) /\
  (forall n. 0 + n = n) /\
  (forall m n. S(m) + n = S(m + n)) /\
  (forall n. 0 * n = 0) /\
  (forall m n. S(m) * n = n + m * n) /\
  (forall m n. m <= n <=> (exists d. m + d = n)) /\
  (forall m n. m < n <=> S(m) <= n) ==>
  (forall m n. S(m) + n = S(m + n))
val mul_0 : thm =
  |-
  (forall m n. S(m) = S(n) ==> m = n) /\
  (forall n. ~n = 0 <=> (exists m. n = S(m))) /\
  (forall n. 0 + n = n) /\
  (forall m n. S(m) + n = S(m + n)) /\
  (forall n. 0 * n = 0) /\
  (forall m n. S(m) * n = n + m * n) /\
  (forall m n. m <= n <=> (exists d. m + d = n)) /\
  (forall m n. m < n <=> S(m) <= n) ==> (forall n. 0 * n = 0)
val mul_suc : thm =
  |-
  (forall m n. S(m) = S(n) ==> m = n) /\
  (forall n. ~n = 0 <=> (exists m. n = S(m))) /\
  (forall n. 0 + n = n) /\
  (forall m n. S(m) + n = S(m + n)) /\
  (forall n. 0 * n = 0) /\
  (forall m n. S(m) * n = n + m * n) /\
  (forall m n. m <= n <=> (exists d. m + d = n)) /\
  (forall m n. m < n <=> S(m) <= n) ==>
  (forall m n. S(m) * n = n + m * n)
val le_def : thm =
  |-
  (forall m n. S(m) = S(n) ==> m = n) /\
  (forall n. ~n = 0 <=> (exists m. n = S(m))) /\
  (forall n. 0 + n = n) /\
  (forall m n. S(m) + n = S(m + n)) /\
  (forall n. 0 * n = 0) /\
  (forall m n. S(m) * n = n + m * n) /\
  (forall m n. m <= n <=> (exists d. m + d = n)) /\
  (forall m n. m < n <=> S(m) <= n) ==>
  (forall m n. m <= n <=> (exists d. m + d = n))
val lt_def : thm =
  |-
  (forall m n. S(m) = S(n) ==> m = n) /\
  (forall n. ~n = 0 <=> (exists m. n = S(m))) /\
  (forall n. 0 + n = n) /\
  (forall m n. S(m) + n = S(m + n)) /\
  (forall n. 0 * n = 0) /\
  (forall m n. S(m) * n = n + m * n) /\
  (forall m n. m <= n <=> (exists d. m + d = n)) /\
  (forall m n. m < n <=> S(m) <= n) ==>
  (forall m n. m < n <=> S(m) <= n)
val right_spec : term -> thm -> thm = <fun>
val right_mp : thm -> thm -> thm = <fun>
val right_imp_trans : thm -> thm -> thm = <fun>
val right_sym : thm -> thm = <fun>
val right_trans : thm -> thm -> thm = <fun>
File "atp_interactive.ml", line 12938, characters 2-347:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Var _
val robop : term -> thm = <fun>
val robeval : term -> thm = <fun>
val robinson_consequences : fol formula =
  <<(forall n. S(n) = 0 ==> false) /\
    (forall n. 0 = S(n) ==> false) /\
    (forall m n. (m = n ==> false) ==> S(m) = S(n) ==> false) /\
    (forall m n. (exists d. m + d = n) ==> m <= n) /\
    (forall m n. S(m) <= n ==> m < n) /\
    (forall m n.
       (forall d. d <= n ==> d = m ==> false) ==> m <= n ==> false) /\
    (forall m n.
       (forall d. d < n ==> d = m ==> false) ==> m < n ==> false) /\
    (forall n. n <= 0 \/ (exists m. S(m) = n)) /\
    (forall n. n <= 0 ==> n = 0) /\
    (forall m n. S(m) <= S(n) ==> m <= n) /\
    (forall m n. m < S(n) ==> m <= n) /\ (forall n. n < 0 ==> false)>>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 6
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 6
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 6
Searching with depth limit 7
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 6
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 6
Searching with depth limit 7
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 6
Searching with depth limit 7
Searching with depth limit 0
Searching with depth limit 1
val robinson_thm : thm =
  |-
  (forall m n. S(m) = S(n) ==> m = n) /\
  (forall n. ~n = 0 <=> (exists m. n = S(m))) /\
  (forall n. 0 + n = n) /\
  (forall m n. S(m) + n = S(m + n)) /\
  (forall n. 0 * n = 0) /\
  (forall m n. S(m) * n = n + m * n) /\
  (forall m n. m <= n <=> (exists d. m + d = n)) /\
  (forall m n. m < n <=> S(m) <= n) ==>
  (forall n. S(n) = 0 ==> false) /\
  (forall n. 0 = S(n) ==> false) /\
  (forall m n. (m = n ==> false) ==> S(m) = S(n) ==> false) /\
  (forall m n. (exists d. m + d = n) ==> m <= n) /\
  (forall m n. S(m) <= n ==> m < n) /\
  (forall m n.
     (forall d. d <= n ==> d = m ==> false) ==> m <= n ==> false) /\
  (forall m n.
     (forall d. d < n ==> d = m ==> false) ==> m < n ==> false) /\
  (forall n. n <= 0 \/ (exists m. S(m) = n)) /\
  (forall n. n <= 0 ==> n = 0) /\
  (forall m n. S(m) <= S(n) ==> m <= n) /\
  (forall m n. m < S(n) ==> m <= n) /\ (forall n. n < 0 ==> false)
File "atp_interactive.ml", line 13074, characters 4-134:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val suc_0_l : thm =
  |-
  (forall m n. S(m) = S(n) ==> m = n) /\
  (forall n. ~n = 0 <=> (exists m. n = S(m))) /\
  (forall n. 0 + n = n) /\
  (forall m n. S(m) + n = S(m + n)) /\
  (forall n. 0 * n = 0) /\
  (forall m n. S(m) * n = n + m * n) /\
  (forall m n. m <= n <=> (exists d. m + d = n)) /\
  (forall m n. m < n <=> S(m) <= n) ==> (forall n. S(n) = 0 ==> false)
val suc_0_r : thm =
  |-
  (forall m n. S(m) = S(n) ==> m = n) /\
  (forall n. ~n = 0 <=> (exists m. n = S(m))) /\
  (forall n. 0 + n = n) /\
  (forall m n. S(m) + n = S(m + n)) /\
  (forall n. 0 * n = 0) /\
  (forall m n. S(m) * n = n + m * n) /\
  (forall m n. m <= n <=> (exists d. m + d = n)) /\
  (forall m n. m < n <=> S(m) <= n) ==> (forall n. 0 = S(n) ==> false)
val suc_inj_false : thm =
  |-
  (forall m n. S(m) = S(n) ==> m = n) /\
  (forall n. ~n = 0 <=> (exists m. n = S(m))) /\
  (forall n. 0 + n = n) /\
  (forall m n. S(m) + n = S(m + n)) /\
  (forall n. 0 * n = 0) /\
  (forall m n. S(m) * n = n + m * n) /\
  (forall m n. m <= n <=> (exists d. m + d = n)) /\
  (forall m n. m < n <=> S(m) <= n) ==>
  (forall m n. (m = n ==> false) ==> S(m) = S(n) ==> false)
val expand_le : thm =
  |-
  (forall m n. S(m) = S(n) ==> m = n) /\
  (forall n. ~n = 0 <=> (exists m. n = S(m))) /\
  (forall n. 0 + n = n) /\
  (forall m n. S(m) + n = S(m + n)) /\
  (forall n. 0 * n = 0) /\
  (forall m n. S(m) * n = n + m * n) /\
  (forall m n. m <= n <=> (exists d. m + d = n)) /\
  (forall m n. m < n <=> S(m) <= n) ==>
  (forall m n. (exists d. m + d = n) ==> m <= n)
val expand_lt : thm =
  |-
  (forall m n. S(m) = S(n) ==> m = n) /\
  (forall n. ~n = 0 <=> (exists m. n = S(m))) /\
  (forall n. 0 + n = n) /\
  (forall m n. S(m) + n = S(m + n)) /\
  (forall n. 0 * n = 0) /\
  (forall m n. S(m) * n = n + m * n) /\
  (forall m n. m <= n <=> (exists d. m + d = n)) /\
  (forall m n. m < n <=> S(m) <= n) ==>
  (forall m n. S(m) <= n ==> m < n)
val expand_nle : thm =
  |-
  (forall m n. S(m) = S(n) ==> m = n) /\
  (forall n. ~n = 0 <=> (exists m. n = S(m))) /\
  (forall n. 0 + n = n) /\
  (forall m n. S(m) + n = S(m + n)) /\
  (forall n. 0 * n = 0) /\
  (forall m n. S(m) * n = n + m * n) /\
  (forall m n. m <= n <=> (exists d. m + d = n)) /\
  (forall m n. m < n <=> S(m) <= n) ==>
  (forall m n.
     (forall d. d <= n ==> d = m ==> false) ==> m <= n ==> false)
val expand_nlt : thm =
  |-
  (forall m n. S(m) = S(n) ==> m = n) /\
  (forall n. ~n = 0 <=> (exists m. n = S(m))) /\
  (forall n. 0 + n = n) /\
  (forall m n. S(m) + n = S(m + n)) /\
  (forall n. 0 * n = 0) /\
  (forall m n. S(m) * n = n + m * n) /\
  (forall m n. m <= n <=> (exists d. m + d = n)) /\
  (forall m n. m < n <=> S(m) <= n) ==>
  (forall m n.
     (forall d. d < n ==> d = m ==> false) ==> m < n ==> false)
val num_lecases : thm =
  |-
  (forall m n. S(m) = S(n) ==> m = n) /\
  (forall n. ~n = 0 <=> (exists m. n = S(m))) /\
  (forall n. 0 + n = n) /\
  (forall m n. S(m) + n = S(m + n)) /\
  (forall n. 0 * n = 0) /\
  (forall m n. S(m) * n = n + m * n) /\
  (forall m n. m <= n <=> (exists d. m + d = n)) /\
  (forall m n. m < n <=> S(m) <= n) ==>
  (forall n. n <= 0 \/ (exists m. S(m) = n))
val le_0 : thm =
  |-
  (forall m n. S(m) = S(n) ==> m = n) /\
  (forall n. ~n = 0 <=> (exists m. n = S(m))) /\
  (forall n. 0 + n = n) /\
  (forall m n. S(m) + n = S(m + n)) /\
  (forall n. 0 * n = 0) /\
  (forall m n. S(m) * n = n + m * n) /\
  (forall m n. m <= n <=> (exists d. m + d = n)) /\
  (forall m n. m < n <=> S(m) <= n) ==> (forall n. n <= 0 ==> n = 0)
val le_suc : thm =
  |-
  (forall m n. S(m) = S(n) ==> m = n) /\
  (forall n. ~n = 0 <=> (exists m. n = S(m))) /\
  (forall n. 0 + n = n) /\
  (forall m n. S(m) + n = S(m + n)) /\
  (forall n. 0 * n = 0) /\
  (forall m n. S(m) * n = n + m * n) /\
  (forall m n. m <= n <=> (exists d. m + d = n)) /\
  (forall m n. m < n <=> S(m) <= n) ==>
  (forall m n. S(m) <= S(n) ==> m <= n)
val lt_suc : thm =
  |-
  (forall m n. S(m) = S(n) ==> m = n) /\
  (forall n. ~n = 0 <=> (exists m. n = S(m))) /\
  (forall n. 0 + n = n) /\
  (forall m n. S(m) + n = S(m + n)) /\
  (forall n. 0 * n = 0) /\
  (forall m n. S(m) * n = n + m * n) /\
  (forall m n. m <= n <=> (exists d. m + d = n)) /\
  (forall m n. m < n <=> S(m) <= n) ==>
  (forall m n. m < S(n) ==> m <= n)
val lt_0 : thm =
  |-
  (forall m n. S(m) = S(n) ==> m = n) /\
  (forall n. ~n = 0 <=> (exists m. n = S(m))) /\
  (forall n. 0 + n = n) /\
  (forall m n. S(m) + n = S(m + n)) /\
  (forall n. 0 * n = 0) /\
  (forall m n. S(m) * n = n + m * n) /\
  (forall m n. m <= n <=> (exists d. m + d = n)) /\
  (forall m n. m < n <=> S(m) <= n) ==> (forall n. n < 0 ==> false)
val rob_eq : term -> term -> thm = <fun>
val rob_nen : term * term -> thm = <fun>
val rob_ne : term -> term -> thm = <fun>
val introduce_connective : fol formula -> thm = <fun>
val elim_bex : fol formula -> thm = <fun>
val sigma_elim : fol formula -> thm = <fun>
File "atp_interactive.ml", line 13153, characters 2-1007:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
((Exists (_, _)|Forall (_, _)|Iff (_, _)|Or (_, _)|And (_, _)|Not _|Atom _|
 True|False),
_)
val boundquant_step : thm -> thm -> thm = <fun>
File "atp_interactive.ml", line 13220, characters 2-971:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
("", _)
val sigma_prove : fol formula -> thm = <fun>
val bounded_prove : string * string * term * fol formula -> thm = <fun>
val boundednum_prove : string * string * term * fol formula -> thm =
  <fun>
	Camlp4 Parsing version 3.09.3

# No printer named printert.
No printer named print_fpf.
val begin_output : unit -> unit = <fun>
val end_output : unit -> unit = <fun>
Warning: File "full_test.ml", line 24, chars 34-35: Invalid backslash escape in string
File "verbose_functions.ml", line 17, characters 4-90:
Warning S: this expression should have type unit.
val print_list : ('a -> 'b) -> 'a list -> unit = <fun>
val print_pair : ('a -> 'b) -> ('c -> 'd) -> 'a * 'c -> unit = <fun>
val print_bool : bool -> unit = <fun>
val variant' : string -> string list -> string = <fun>
val subst' : (string, term) func -> fol formula -> fol formula = <fun>
val icongruence' : term -> term -> term -> term -> thm = <fun>
val ispec' : term -> fol formula -> thm = <fun>
val isubst' : term -> term -> fol formula -> fol formula -> thm = <fun>
val lex' : string list -> string list = <fun>
val lcffol' : fol formula -> thm = <fun>
val lcftaut' : fol formula -> thm = <fun>
val set_goal' : fol formula -> goals = <fun>
val imp_intro_tac' : string -> goals -> goals = <fun>
val conj_intro_tac' : goals -> goals = <fun>
val extract_thm' : goals -> thm = <fun>
val prove' : fol formula -> (goals -> goals) list -> thm = <fun>
val unify_and_apply' : (term * term) list -> (term * term) list = <fun>
********************
********TEST********
********************\;- : unit
                                                                = ()
- : dummy_interactive = START_INTERACTIVE
:::
sqrt(1 - power(cos(x + y),2))
;;;
- : unit = ()
- : dummy_interactive = END_INTERACTIVE
- : dummy_interactive = START_INTERACTIVE
:::
<<x + y < z>>
;;;
- : unit = ()
- : dummy_interactive = END_INTERACTIVE
- : dummy_interactive = START_INTERACTIVE
:::
<<(forall x. x < 2 ==> 2 * x <= 3) \/ false>>
;;;
- : unit = ()
:::
2 *
x
;;;
- : unit = ()
- : dummy_interactive = END_INTERACTIVE
- : dummy_interactive = START_INTERACTIVE
:::
<<forall x y. exists z. x < z /\ y < z>>
;;;
- : unit = ()
:::
<<~(forall x. P(x)) <=> (exists y. ~P(y))>>
;;;
- : unit = ()
- : dummy_interactive = END_INTERACTIVE
- : dummy_interactive = START_INTERACTIVE
:::
x
;;;
- : string = "x"
:::
x'
;;;
- : string = "x'"
:::
x''
;;;
- : string = "x''"
- : dummy_interactive = END_INTERACTIVE
- : dummy_interactive = START_INTERACTIVE
:::
<<forall x'. x' = x>>
;;;
- : fol formula = Forall ("x'", Atom (R ("=", [Var "x'"; Var "x"])))
:::
<<forall x' x''. x' = x ==> x' = x''>>
;;;
- : fol formula =
Forall ("x'",
 Forall ("x''",
  Imp (Atom (R ("=", [Var "x'"; Var "x"])),
   Atom (R ("=", [Var "x'"; Var "x''"])))))
- : dummy_interactive = END_INTERACTIVE
- : dummy_interactive = START_INTERACTIVE
:::
|- s = t ==> f(s,g(s,t,s),u,h(h(s))) = f(s,g(t,t,s),u,h(h(t)))
;;;
- : thm = <abstr>
- : dummy_interactive = END_INTERACTIVE
- : dummy_interactive = START_INTERACTIVE
:::
|-
(forall x y z. x + y + z = z + y + x) ==>
(forall y' z. y + y' + z = z + y' + y)
;;;
- : thm = <abstr>
:::
|- x + x = 2 * x ==> (x + x = x ==> x = 0) ==> 2 * x = x ==> x = 0
;;;
- : thm = <abstr>
:::
|-
x + x = 2 * x ==>
(x + x = y + y ==> y + y + y = x + x + x) ==>
2 * x = y + y ==> y + y + y = x + 2 * x
;;;
- : thm = <abstr>
:::
|-
(forall x y z. x + y + z = y + z + z) ==>
(forall y z. x + y + z = y + z + z)
;;;
- : thm = <abstr>
:::
|- (forall x. x = x) ==> x = x
;;;
- : thm = <abstr>
:::
|-
(forall x y z. x + y + z = y + z + z) ==>
(forall y' z'. (w + y + z) + y' + z' = y' + z' + z')
;;;
- : thm = <abstr>
:::
|-
(forall x y z. x + y + z = y + z + z) ==>
(forall y' z'. (x + y + z) + y' + z' = y' + z' + z')
;;;
- : thm = <abstr>
:::
|- (forall x y z. nothing_much) ==> (forall y z. nothing_much)
;;;
- : thm = <abstr>
:::
|-
x + x = 2 * x ==>
(x + x = y + y <=> something \/ y + y + y = x + x + x) ==>
(2 * x = y + y <=> something \/ y + y + y = x + x + x)
;;;
- : thm = <abstr>
:::
|-
x + x = 2 * x ==>
((exists x. x = 2) <=> (exists y. y + x + x = y + y + y)) ==>
((exists x. x = 2) <=> (exists y. y + 2 * x = y + y + y))
;;;
- : thm = <abstr>
:::
|-
x = y ==>
((forall z. x = z) <=> (exists x. y < z) /\ (forall y. y < x)) ==>
((forall z. y = z) <=> (exists x. y < z) /\ (forall y'. y' < y))
;;;
- : thm = <abstr>
:::
|-
(forall x x' x''. x + x' + x'' = 0) ==>
(forall x'' x'''. x' + x'' + x''' = 0)
;;;
- : thm = <abstr>
:::
|-
(forall x x' x''. x + x' + x'' = 0) ==>
(forall x' x'''. x'' + x' + x''' = 0)
;;;
- : thm = <abstr>
:::
|-
(forall x x' x''. x + x' + x'' = 0) ==>
(forall x''' x''''. (x' + x'') + x''' + x'''' = 0)
;;;
- : thm = <abstr>
:::
|-
(forall x x' x''. x + x' + x'' = 0) ==>
(forall x''' x''''. (x + x' + x'') + x''' + x'''' = 0)
;;;
- : thm = <abstr>
:::
|-
(forall x x'. x + x' = x' + x) ==> (forall x'. 2 * x + x' = x' + 2 * x)
;;;
- : thm = <abstr>
- : dummy_interactive = END_INTERACTIVE
- : dummy_interactive = START_INTERACTIVE
:::
[2,*,(,(,var_1,+,x',),+,11,)]
;;;
- : string list =
["2"; "*"; "("; "("; "var_1"; "+"; "x'"; ")"; "+"; "11"; ")"]
:::
[if,(,*,p1,--,==,*,p2,++,),then,f,(,),else,g,(,)]
;;;
- : string list =
["if"; "("; "*"; "p1"; "--"; "=="; "*"; "p2"; "++"; ")"; "then"; "f";
 "("; ")"; "else"; "g"; "("; ")"]
- : dummy_interactive = END_INTERACTIVE
- : dummy_interactive = START_INTERACTIVE
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
:::
|-
forall x.
  exists v w.
    forall y z. P(x) /\ Q(y) ==> (P(v) \/ R(w)) /\ (R(z) ==> Q(v))
;;;
val p58 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 6
:::
|-
(forall x. x <= x) /\
(forall x y z. x <= y /\ y <= z ==> x <= z) /\
(forall x y. f(x) <= y <=> x <= g(y)) ==>
(forall x y. x <= y ==> f(x) <= f(y))
;;;
val ewd1062_1 : thm = <abstr>
- : dummy_interactive = END_INTERACTIVE
- : dummy_interactive = START_INTERACTIVE
val start_time : float = 14.948
:::
|- p ==> q <=> ~q ==> ~p
;;;
CPU time (user): 0.008
val p1 : thm = <abstr>
:::
|- ~(~p) <=> p
;;;
CPU time (user): 0.
val p2 : thm = <abstr>
:::
|- ~(p ==> q) ==> q ==> p
;;;
CPU time (user): 0.
val p3 : thm = <abstr>
:::
|- ~p ==> q <=> ~q ==> p
;;;
CPU time (user): 0.004
val p4 : thm = <abstr>
:::
|- (p \/ q ==> p \/ r) ==> p \/ (q ==> r)
;;;
CPU time (user): 0.004
val p5 : thm = <abstr>
:::
|- p \/ ~p
;;;
CPU time (user): 0.
val p6 : thm = <abstr>
:::
|- p \/ ~(~(~p))
;;;
CPU time (user): 0.
val p7 : thm = <abstr>
:::
|- ((p ==> q) ==> p) ==> p
;;;
CPU time (user): 0.004
val p8 : thm = <abstr>
:::
|- (p \/ q) /\ (~p \/ q) /\ (p \/ ~q) ==> ~(~q \/ ~q)
;;;
CPU time (user): 0.012
val p9 : thm = <abstr>
:::
|- (q ==> r) /\ (r ==> p /\ q) /\ (p ==> q /\ r) ==> (p <=> q)
;;;
CPU time (user): 0.004
val p10 : thm = <abstr>
:::
|- p <=> p
;;;
CPU time (user): 0.
val p11 : thm = <abstr>
:::
|- ((p <=> q) <=> r) <=> p <=> q <=> r
;;;
CPU time (user): 0.048
val p12 : thm = <abstr>
:::
|- p \/ q /\ r <=> (p \/ q) /\ (p \/ r)
;;;
CPU time (user): 0.008
val p13 : thm = <abstr>
:::
|- (p <=> q) <=> (q \/ ~p) /\ (~q \/ p)
;;;
CPU time (user): 0.012
val p14 : thm = <abstr>
:::
|- p ==> q <=> ~p \/ q
;;;
CPU time (user): 0.004
val p15 : thm = <abstr>
:::
|- (p ==> q) \/ (q ==> p)
;;;
CPU time (user): 0.
val p16 : thm = <abstr>
:::
|- p /\ (q ==> r) ==> s <=> (~p \/ q \/ s) /\ (~p \/ ~r \/ s)
;;;
CPU time (user): 0.032
val p17 : thm = <abstr>
Searching with depth limit 0
:::
|- p ==> q <=> ~q ==> ~p
;;;
CPU time (user): 0.004
val p1 : thm = <abstr>
Searching with depth limit 0
:::
|- ~(~p) <=> p
;;;
CPU time (user): 0.004
val p2 : thm = <abstr>
Searching with depth limit 0
:::
|- ~(p ==> q) ==> q ==> p
;;;
CPU time (user): 0.
val p3 : thm = <abstr>
Searching with depth limit 0
:::
|- ~p ==> q <=> ~q ==> p
;;;
CPU time (user): 0.004
val p4 : thm = <abstr>
Searching with depth limit 0
:::
|- (p \/ q ==> p \/ r) ==> p \/ (q ==> r)
;;;
CPU time (user): 0.004
val p5 : thm = <abstr>
Searching with depth limit 0
:::
|- p \/ ~p
;;;
CPU time (user): 0.008
val p6 : thm = <abstr>
Searching with depth limit 0
:::
|- p \/ ~(~(~p))
;;;
CPU time (user): 0.
val p7 : thm = <abstr>
Searching with depth limit 0
:::
|- ((p ==> q) ==> p) ==> p
;;;
CPU time (user): 0.
val p8 : thm = <abstr>
Searching with depth limit 0
:::
|- (p \/ q) /\ (~p \/ q) /\ (p \/ ~q) ==> ~(~q \/ ~q)
;;;
CPU time (user): 0.012
val p9 : thm = <abstr>
Searching with depth limit 0
:::
|- (q ==> r) /\ (r ==> p /\ q) /\ (p ==> q /\ r) ==> (p <=> q)
;;;
CPU time (user): 0.008
val p10 : thm = <abstr>
Searching with depth limit 0
:::
|- p <=> p
;;;
CPU time (user): 0.004
val p11 : thm = <abstr>
Searching with depth limit 0
:::
|- ((p <=> q) <=> r) <=> p <=> q <=> r
;;;
CPU time (user): 0.072
val p12 : thm = <abstr>
Searching with depth limit 0
:::
|- p \/ q /\ r <=> (p \/ q) /\ (p \/ r)
;;;
CPU time (user): 0.016
val p13 : thm = <abstr>
Searching with depth limit 0
:::
|- (p <=> q) <=> (q \/ ~p) /\ (~q \/ p)
;;;
CPU time (user): 0.016
val p14 : thm = <abstr>
Searching with depth limit 0
:::
|- p ==> q <=> ~p \/ q
;;;
CPU time (user): 0.004
val p15 : thm = <abstr>
Searching with depth limit 0
:::
|- (p ==> q) \/ (q ==> p)
;;;
CPU time (user): 0.004
val p16 : thm = <abstr>
Searching with depth limit 0
:::
|- p /\ (q ==> r) ==> s <=> (~p \/ q \/ s) /\ (~p \/ ~r \/ s)
;;;
CPU time (user): 0.04
val p17 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
:::
|- exists y. forall x. P(y) ==> P(x)
;;;
CPU time (user): 0.012
val p18 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
:::
|- exists x. forall y z. (P(y) ==> Q(z)) ==> P(x) ==> Q(x)
;;;
CPU time (user): 0.112
val p19 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
:::
|-
(forall x y. exists z. forall w. P(x) /\ Q(y) ==> R(z) /\ U(w)) ==>
(exists x y. P(x) /\ Q(y)) ==> (exists z. R(z))
;;;
CPU time (user): 0.092
val p20 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
:::
|-
(exists x. P ==> Q(x)) /\ (exists x. Q(x) ==> P) ==>
(exists x. P <=> Q(x))
;;;
CPU time (user): 0.044
val p21 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
:::
|- (forall x. P <=> Q(x)) ==> (P <=> (forall x. Q(x)))
;;;
CPU time (user): 0.016
val p22 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
:::
|- (forall x. P \/ Q(x)) <=> P \/ (forall x. Q(x))
;;;
CPU time (user): 0.024
val p23 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 6
:::
|-
~(exists x. U(x) /\ Q(x)) /\
(forall x. P(x) ==> Q(x) \/ R(x)) /\
~(exists x. P(x) ==> (exists x. Q(x))) /\
(forall x. Q(x) /\ R(x) ==> U(x)) ==> (exists x. P(x) /\ R(x))
;;;
CPU time (user): 0.108
val p24 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
:::
|-
(exists x. P(x)) /\
(forall x. U(x) ==> ~G(x) /\ R(x)) /\
(forall x. P(x) ==> G(x) /\ U(x)) /\
((forall x. P(x) ==> Q(x)) \/ (exists x. Q(x) /\ P(x))) ==>
(exists x. Q(x) /\ P(x))
;;;
CPU time (user): 0.028
val p25 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
:::
|-
((exists x. P(x)) <=> (exists x. Q(x))) /\
(forall x y. P(x) /\ Q(y) ==> (R(x) <=> U(y))) ==>
((forall x. P(x) ==> R(x)) <=> (forall x. Q(x) ==> U(x)))
;;;
CPU time (user): 0.636
val p26 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
:::
|-
(exists x. P(x) /\ ~Q(x)) /\
(forall x. P(x) ==> R(x)) /\
(forall x. U(x) /\ V(x) ==> P(x)) /\ (exists x. R(x) /\ ~Q(x)) ==>
(forall x. V(x) ==> ~R(x)) ==> (forall x. U(x) ==> ~V(x))
;;;
CPU time (user): 0.22
val p27 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
:::
|-
(forall x. P(x) ==> (forall x. Q(x))) /\
((forall x. Q(x) \/ R(x)) ==> (exists x. Q(x) /\ R(x))) /\
((exists x. R(x)) ==> (forall x. L(x) ==> M(x))) ==>
(forall x. P(x) /\ L(x) ==> M(x))
;;;
CPU time (user): 0.164
val p28 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
:::
|-
(exists x. P(x)) /\ (exists x. G(x)) ==>
((forall x. P(x) ==> H(x)) /\ (forall x. G(x) ==> J(x)) <=>
 (forall x y. P(x) /\ G(y) ==> H(x) /\ J(y)))
;;;
CPU time (user): 0.256
val p29 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
:::
|-
(forall x. P(x) \/ G(x) ==> ~H(x)) /\
(forall x. (G(x) ==> ~U(x)) ==> P(x) /\ H(x)) ==> (forall x. U(x))
;;;
CPU time (user): 0.024
val p30 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
:::
|-
~(exists x. P(x) /\ (G(x) \/ H(x))) /\
(exists x. Q(x) /\ P(x)) /\ (forall x. ~H(x) ==> J(x)) ==>
(exists x. Q(x) /\ J(x))
;;;
CPU time (user): 0.044
val p31 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
:::
|-
(forall x. P(x) /\ (G(x) \/ H(x)) ==> Q(x)) /\
(forall x. Q(x) /\ H(x) ==> J(x)) /\ (forall x. R(x) ==> H(x)) ==>
(forall x. P(x) /\ R(x) ==> J(x))
;;;
CPU time (user): 0.144
val p32 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
:::
|-
(forall x. P(a) /\ (P(x) ==> P(b)) ==> P(c)) <=>
(forall x. P(a) ==> P(x) \/ P(c)) /\ (P(a) ==> P(b) ==> P(c))
;;;
CPU time (user): 0.524
val p33 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
:::
|- exists x y. P(x,y) ==> (forall x y. P(x,y))
;;;
CPU time (user): 0.012
val p35 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 6
:::
|-
(forall x. exists y. P(x,y)) /\
(forall x. exists y. G(x,y)) /\
(forall x y.
   P(x,y) \/ G(x,y) ==> (forall z. P(y,z) \/ G(y,z) ==> H(x,z))) ==>
(forall x. exists y. H(x,y))
;;;
CPU time (user): 0.072
val p36 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 6
:::
|-
(forall z.
   exists w.
     forall x.
       exists y.
         (P(x,z) ==> P(y,w)) /\
         P(y,z) /\ (P(y,w) ==> (exists u. Q(u,w)))) /\
(forall x z. ~P(x,z) ==> (exists y. Q(y,z))) /\
((exists x y. Q(x,y)) ==> (forall x. R(x,x))) ==>
(forall x. exists y. R(x,y))
;;;
CPU time (user): 0.584
val p37 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
:::
|-
(forall x.
   P(a) /\ (P(x) ==> (exists y. P(y) /\ R(x,y))) ==>
   (exists z w. P(z) /\ R(x,w) /\ R(w,z))) <=>
(forall x.
   (~P(a) \/ P(x) \/ (exists z w. P(z) /\ R(x,w) /\ R(w,z))) /\
   (~P(a) \/
    ~(exists y. P(y) /\ R(x,y)) \/
    (exists z w. P(z) /\ R(x,w) /\ R(w,z))))
;;;
CPU time (user): 4.656
val p38 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
:::
|- ~(exists x. forall y. P(y,x) <=> ~P(y,y))
;;;
CPU time (user): 0.044
val p39 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
:::
|-
(exists y. forall x. P(x,y) <=> P(x,x)) ==>
~(forall x. exists y. forall z. P(z,y) <=> ~P(z,x))
;;;
CPU time (user): 0.108
val p40 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
:::
|-
(forall z. exists y. forall x. P(x,y) <=> P(x,z) /\ ~P(x,x)) ==>
~(exists z. forall x. P(x,z))
;;;
CPU time (user): 0.06
val p41 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
:::
|- ~(exists y. forall x. P(x,y) <=> ~(exists z. P(x,z) /\ P(z,x)))
;;;
CPU time (user): 0.244
val p42 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
:::
|-
(forall x.
   P(x) ==> (exists y. G(y) /\ H(x,y)) /\ (exists y. G(y) /\ ~H(x,y))) /\
(exists x. J(x) /\ (forall y. G(y) ==> H(x,y))) ==>
(exists x. J(x) /\ ~P(x))
;;;
CPU time (user): 0.148
val p44 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 6
Searching with depth limit 7
Searching with depth limit 8
:::
|-
lives(agatha) /\
lives(butler) /\
lives(charles) /\
(killed(agatha,agatha) \/
 killed(butler,agatha) \/ killed(charles,agatha)) /\
(forall x y. killed(x,y) ==> hates(x,y) /\ ~richer(x,y)) /\
(forall x. hates(agatha,x) ==> ~hates(charles,x)) /\
(hates(agatha,agatha) /\ hates(agatha,charles)) /\
(forall x. lives(x) /\ ~richer(x,agatha) ==> hates(butler,x)) /\
(forall x. hates(agatha,x) ==> hates(butler,x)) /\
(forall x. ~hates(x,agatha) \/ ~hates(x,butler) \/ ~hates(x,charles)) ==>
killed(agatha,agatha) /\
~killed(butler,agatha) /\ ~killed(charles,agatha)
;;;
CPU time (user): 30.048
val p55 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
:::
|-
P(f(a,b),f(b,c)) /\
P(f(b,c),f(a,c)) /\ (forall x y z. P(x,y) /\ P(y,z) ==> P(x,z)) ==>
P(f(a,b),f(a,c))
;;;
CPU time (user): 0.14
val p57 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
:::
|-
forall P Q R x.
  exists v w.
    forall y z. P(x) /\ Q(y) ==> (P(v) \/ R(w)) /\ (R(z) ==> Q(v))
;;;
CPU time (user): 0.328
val p58 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
:::
|- (forall x. P(x) <=> ~P(f(x))) ==> (exists x. P(x) /\ ~P(f(x)))
;;;
CPU time (user): 0.024
val p59 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
:::
|-
forall x.
  P(x,f(x)) <=> (exists y. (forall z. P(z,y) ==> P(z,f(x))) /\ P(x,y))
;;;
CPU time (user): 0.068
val p60 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
:::
|-
exists x.
  forall y z.
    ((F(y,z) ==> G(y) ==> H(x)) ==> F(x,x)) /\
    ((F(z,x) ==> G(x)) ==> H(z)) /\ F(x,y) ==> F(z,z)
;;;
CPU time (user): 2.784
val gilmore_3 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 6
Searching with depth limit 7
:::
|-
exists x y.
  forall z.
    (F(x,y) ==> F(y,z) /\ F(z,z)) /\
    (F(x,y) /\ G(x,y) ==> G(x,z) /\ G(z,z))
;;;
CPU time (user): 8.928
val gilmore_4 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
:::
|-
(forall x. exists y. F(x,y) \/ F(y,x)) /\
(forall x y. F(y,x) ==> F(y,y)) ==> (exists z. F(z,z))
;;;
CPU time (user): 0.028
val gilmore_5 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
:::
|-
forall x.
  exists y.
    (exists u. forall v. F(u,x) ==> G(v,u) /\ G(u,x)) ==>
    (exists u. forall v. F(u,y) ==> G(v,u) /\ G(u,y)) \/
    (forall u v. exists w. G(v,u) \/ H(w,y,u) ==> G(u,w))
;;;
CPU time (user): 0.144
val gilmore_6 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
:::
|-
(forall x. K(x) ==> (exists y. L(y) /\ (F(x,y) ==> G(x,y)))) /\
(exists z. K(z) /\ (forall u. L(u) ==> F(z,u))) ==>
(exists v w. K(v) /\ L(w) /\ G(v,w))
;;;
CPU time (user): 0.068
val gilmore_7 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 6
Searching with depth limit 7
:::
|-
exists x.
  forall y z.
    ((F(y,z) ==> G(y) ==> (forall u. exists v. H(u,v,x))) ==> F(x,x)) /\
    ((F(z,x) ==> G(x)) ==> (forall u. exists v. H(u,v,z))) /\ F(x,y) ==>
    F(z,z)
;;;
CPU time (user): 11.364
val gilmore_8 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 6
:::
|-
forall x.
  exists y.
    forall z.
      ((forall u. exists v. F(y,u,v) /\ G(y,u) /\ ~H(y,x)) ==>
       (forall u. exists v. F(x,u,v) /\ G(z,u) /\ ~H(x,z)) ==>
       (forall u. exists v. F(x,u,v) /\ G(y,u) /\ ~H(x,y))) /\
      ((forall u. exists v. F(x,u,v) /\ G(y,u) /\ ~H(x,y)) ==>
       ~(forall u. exists v. F(x,u,v) /\ G(z,u) /\ ~H(x,z)) ==>
       (forall u. exists v. F(y,u,v) /\ G(y,u) /\ ~H(y,x)) /\
       (forall u. exists v. F(z,u,v) /\ G(y,u) /\ ~H(z,y)))
;;;
CPU time (user): 13.828
val gilmore_9 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 6
Searching with depth limit 7
:::
|-
exists x y.
  forall z.
    (F(x,y) ==> F(y,z) /\ F(z,z)) /\
    (F(x,y) /\ G(x,y) ==> G(x,z) /\ G(z,z))
;;;
CPU time (user): 9.136
val davis_putnam_example : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 6
:::
|-
(forall x. x <= x) /\
(forall x y z. x <= y /\ y <= z ==> x <= z) /\
(forall x y. f(x) <= y <=> x <= g(y)) ==>
(forall x y. x <= y ==> f(x) <= f(y))
;;;
CPU time (user): 0.212
val ewd1062_1 : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 6
:::
|-
(forall x. x <= x) /\
(forall x y z. x <= y /\ y <= z ==> x <= z) /\
(forall x y. f(x) <= y <=> x <= g(y)) ==>
(forall x y. x <= y ==> g(x) <= g(y))
;;;
CPU time (user): 0.28
val ewd1062_2 : thm = <abstr>
Complete CPU time (user): 86.504- : unit = ()

- : unit = ()
- : dummy_interactive = END_INTERACTIVE
- : dummy_interactive = START_INTERACTIVE
val s : term = Fn ("f", [Var "x"; Var "x"; Var "x"])
val t : term = Fn ("g", [Var "x"; Var "y"])
:::
f(x,x,x)
;;;
- : unit = ()
:::
g(x,y)
;;;
- : unit = ()
:::
true

;;;
- : unit = ()
val i : (string, term) func =
  Leaf (121, [("y", Fn ("f", [Var "x"; Var "x"; Var "x"]))])
:::
false

;;;
- : unit = ()
- : dummy_interactive = END_INTERACTIVE
- : dummy_interactive = START_INTERACTIVE
:::

1 subgoal:
---> (forall x. x <= x) /\
     (forall x y z. x <= y /\ y <= z ==> x <= z) /\
     (forall x y. f(x) <= y <=> x <= g(y)) ==>
     (forall x y. x <= y ==> f(x) <= f(y)) /\
     (forall x y. x <= y ==> g(x) <= g(y))

;;;
val g0 : goals =
  Goals
   ([([],
      Imp
       (And (Forall ("x", Atom (R ("<=", [Var "x"; Var "x"]))),
         And
          (Forall ("x",
            Forall ("y",
             Forall ("z",
              Imp
               (And (Atom (R ("<=", [Var "x"; Var "y"])),
                 Atom (R ("<=", [Var "y"; Var "z"]))),
               Atom (R ("<=", [Var "x"; Var "z"])))))),
          Forall ("x",
           Forall ("y",
            Iff (Atom (R ("<=", [Fn ("f", [Var "x"]); Var "y"])),
             Atom (R ("<=", [Var "x"; Fn ("g", [Var "y"])]))))))),
       And
        (Forall ("x",
          Forall ("y",
           Imp (Atom (R ("<=", [Var "x"; Var "y"])),
            Atom (R ("<=", [Fn ("f", [Var "x"]); Fn ("f", [Var "y"])]))))),
        Forall ("x",
         Forall ("y",
          Imp (Atom (R ("<=", [Var "x"; Var "y"])),
           Atom (R ("<=", [Fn ("g", [Var "x"]); Fn ("g", [Var "y"])]))))))))],
   <fun>)
:::

1 subgoal:
ant: (forall x. x <= x) /\
     (forall x y z. x <= y /\ y <= z ==> x <= z) /\
     (forall x y. f(x) <= y <=> x <= g(y))
---> (forall x y. x <= y ==> f(x) <= f(y)) /\
     (forall x y. x <= y ==> g(x) <= g(y))

;;;
val g1 : goals =
  Goals
   ([([("ant",
        And (Forall ("x", Atom (R ("<=", [Var "x"; Var "x"]))),
         And
          (Forall ("x",
            Forall ("y",
             Forall ("z",
              Imp
               (And (Atom (R ("<=", [Var "x"; Var "y"])),
                 Atom (R ("<=", [Var "y"; Var "z"]))),
               Atom (R ("<=", [Var "x"; Var "z"])))))),
          Forall ("x",
           Forall ("y",
            Iff (Atom (R ("<=", [Fn ("f", [Var "x"]); Var "y"])),
             Atom (R ("<=", [Var "x"; Fn ("g", [Var "y"])]))))))))],
      And
       (Forall ("x",
         Forall ("y",
          Imp (Atom (R ("<=", [Var "x"; Var "y"])),
           Atom (R ("<=", [Fn ("f", [Var "x"]); Fn ("f", [Var "y"])]))))),
       Forall ("x",
        Forall ("y",
         Imp (Atom (R ("<=", [Var "x"; Var "y"])),
          Atom (R ("<=", [Fn ("g", [Var "x"]); Fn ("g", [Var "y"])])))))))],
   <fun>)
:::

2 subgoals starting with
ant: (forall x. x <= x) /\
     (forall x y z. x <= y /\ y <= z ==> x <= z) /\
     (forall x y. f(x) <= y <=> x <= g(y))
---> forall x y. x <= y ==> f(x) <= f(y)

;;;
val g2 : goals =
  Goals
   ([([("ant",
        And (Forall ("x", Atom (R ("<=", [Var "x"; Var "x"]))),
         And
          (Forall ("x",
            Forall ("y",
             Forall ("z",
              Imp
               (And (Atom (R ("<=", [Var "x"; Var "y"])),
                 Atom (R ("<=", [Var "y"; Var "z"]))),
               Atom (R ("<=", [Var "x"; Var "z"])))))),
          Forall ("x",
           Forall ("y",
            Iff (Atom (R ("<=", [Fn ("f", [Var "x"]); Var "y"])),
             Atom (R ("<=", [Var "x"; Fn ("g", [Var "y"])]))))))))],
      Forall ("x",
       Forall ("y",
        Imp (Atom (R ("<=", [Var "x"; Var "y"])),
         Atom (R ("<=", [Fn ("f", [Var "x"]); Fn ("f", [Var "y"])]))))));
     ([("ant",
        And (Forall ("x", Atom (R ("<=", [Var "x"; Var "x"]))),
         And
          (Forall ("x",
            Forall ("y",
             Forall ("z",
              Imp
               (And (Atom (R ("<=", [Var "x"; Var "y"])),
                 Atom (R ("<=", [Var "y"; Var "z"]))),
               Atom (R ("<=", [Var "x"; Var "z"])))))),
          Forall ("x",
           Forall ("y",
            Iff (Atom (R ("<=", [Fn ("f", [Var "x"]); Var "y"])),
             Atom (R ("<=", [Var "x"; Fn ("g", [Var "y"])]))))))))],
      Forall ("x",
       Forall ("y",
        Imp (Atom (R ("<=", [Var "x"; Var "y"])),
         Atom (R ("<=", [Fn ("g", [Var "x"]); Fn ("g", [Var "y"])]))))))],
   <fun>)
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 6
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 6
val g3 : goals = Goals ([], <fun>)
:::
No subgoals
;;;
- : unit = ()
:::
|-
(forall x. x <= x) /\
(forall x y z. x <= y /\ y <= z ==> x <= z) /\
(forall x y. f(x) <= y <=> x <= g(y)) ==>
(forall x y. x <= y ==> f(x) <= f(y)) /\
(forall x y. x <= y ==> g(x) <= g(y))
;;;
- : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 6
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 6
:::
|-
(forall x. x <= x) /\
(forall x y z. x <= y /\ y <= z ==> x <= z) /\
(forall x y. f(x) <= y <=> x <= g(y)) ==>
(forall x y. x <= y ==> f(x) <= f(y)) /\
(forall x y. x <= y ==> g(x) <= g(y))
;;;
- : thm = <abstr>
- : dummy_interactive = END_INTERACTIVE
- : dummy_interactive = START_INTERACTIVE
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 3
Searching with depth limit 4
Searching with depth limit 5
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
:::
|-
(forall x y. x <= y <=> x * y = x) /\
(forall x y. f(x * y) = f(x) * f(y)) ==>
(forall x y. x <= y ==> f(x) <= f(y))
;;;
val ewd954 : thm = <abstr>
- : dummy_interactive = END_INTERACTIVE
- : dummy_interactive = START_INTERACTIVE
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 0
Searching with depth limit 1
:::
|-
(exists x. p(x)) ==>
(forall x. p(x) ==> p(f(x))) ==> (exists y. p(f(f(f(f(y))))))
;;;
- : thm = <abstr>
File "full_test.ml", line 586, characters 17-46:
Warning Y: unused variable gl.
File "full_test.ml", line 588, characters 8-99:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
File "full_test.ml", line 586, characters 4-9:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Goals ([], _)
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 0
Searching with depth limit 1
:::
|-
(exists x. p(x)) ==>
(forall x. p(x) ==> p(f(x))) ==> (exists y. p(f(f(f(f(y))))))
;;;
- : thm = <abstr>
val run : ('a -> 'a) list -> 'a -> 'a = <fun>
val current_goal : goals list ref =
  {contents = [Goals ([([], False)], <fun>)]}
val g : fol formula -> goals = <fun>
val e : (goals -> goals) -> goals = <fun>
val es : (goals -> goals) list -> goals = <fun>
val b : unit -> goals = <fun>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
:::
|-
p(a) ==> (forall x. p(x) ==> p(f(x))) ==> (exists y. p(y) /\ p(f(y)))
;;;
- : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 2
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 0
Searching with depth limit 1
:::
|-
(exists x. p(x)) ==>
(forall x. p(x) ==> p(f(x))) ==> (exists y. p(f(f(f(f(y))))))
;;;
- : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 0
:::
|-
forall a.
  p(a) ==> (forall x. p(x) ==> p(f(x))) ==> (exists y. p(y) /\ p(f(y)))
;;;
- : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
:::
|-
p(c) ==> (forall x. p(x) ==> p(f(x))) ==> (exists y. p(y) /\ p(f(y)))
;;;
- : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 0
:::
|-
forall a.
  p(a) ==> (forall x. p(x) ==> p(f(x))) ==> (exists y. p(y) /\ p(f(y)))
;;;
- : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 0
:::
|-
forall a.
  p(a) ==> (forall x. p(x) ==> p(f(x))) ==> (exists y. p(y) /\ p(f(y)))
;;;
- : thm = <abstr>
:::
|- p(a) \/ p(b) ==> q ==> (exists y. p(y))
;;;
- : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 0
Searching with depth limit 0
Searching with depth limit 1
:::
|-
(p(a) \/ p(b)) /\ (forall x. p(x) ==> p(f(x))) ==> (exists y. p(f(y)))
;;;
- : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 0
Searching with depth limit 1
:::
|-
(exists x. p(x)) ==>
(forall x. p(x) ==> p(f(x))) ==> (exists y. p(f(y)))
;;;
- : thm = <abstr>
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 0
Searching with depth limit 1
Searching with depth limit 0
:::
|-
(forall x. p(x) ==> q(x)) ==>
(forall x. q(x) ==> p(x)) ==> (p(a) <=> q(a))
;;;
- : thm = <abstr>
- : dummy_interactive = END_INTERACTIVE
- : dummy_interactive = START_INTERACTIVE
:::
[(f(f(z),g(y)),f(f(z),g(y)))]
;;;
- : (term * term) list =
[(Fn ("f", [Fn ("f", [Var "z"]); Fn ("g", [Var "y"])]),
  Fn ("f", [Fn ("f", [Var "z"]); Fn ("g", [Var "y"])]))]
:::
[(f(y,y),f(y,y))]
;;;
- : (term * term) list =
[(Fn ("f", [Var "y"; Var "y"]), Fn ("f", [Var "y"; Var "y"]))]
:::
[(f(f(f(x_3,x_3),f(x_3,x_3)),f(f(x_3,x_3),f(x_3,x_3))),f(f(f(x_3,x_3),
                                                           f(x_3,x_3))
                                                         ,
                                                         f(f(x_3,x_3),
                                                           f(x_3,x_3))))
 ,(f(f(x_3,x_3),f(x_3,x_3)),f(f(x_3,x_3),f(x_3,x_3))),
 (f(x_3,x_3),f(x_3,x_3))]
;;;
- : (term * term) list =
[(Fn ("f",
   [Fn ("f",
     [Fn ("f", [Var "x_3"; Var "x_3"]);
      Fn ("f", [Var "x_3"; Var "x_3"])]);
    Fn ("f",
     [Fn ("f", [Var "x_3"; Var "x_3"]);
      Fn ("f", [Var "x_3"; Var "x_3"])])]),
  Fn ("f",
   [Fn ("f",
     [Fn ("f", [Var "x_3"; Var "x_3"]);
      Fn ("f", [Var "x_3"; Var "x_3"])]);
    Fn ("f",
     [Fn ("f", [Var "x_3"; Var "x_3"]);
      Fn ("f", [Var "x_3"; Var "x_3"])])]));
 (Fn ("f",
   [Fn ("f", [Var "x_3"; Var "x_3"]); Fn ("f", [Var "x_3"; Var "x_3"])]),
  Fn ("f",
   [Fn ("f", [Var "x_3"; Var "x_3"]); Fn ("f", [Var "x_3"; Var "x_3"])]));
 (Fn ("f", [Var "x_3"; Var "x_3"]), Fn ("f", [Var "x_3"; Var "x_3"]))]
- : dummy_interactive = END_INTERACTIVE
- : dummy_interactive = START_INTERACTIVE
:::
|- (p ==> q) \/ (q ==> p)
;;;
- : thm = <abstr>
:::
|- p /\ q <=> (p <=> q) <=> p \/ q
;;;
- : thm = <abstr>
:::
|- ((p <=> q) <=> r) <=> p <=> q <=> r
;;;
- : thm = <abstr>
- : dummy_interactive = END_INTERACTIVE
# 